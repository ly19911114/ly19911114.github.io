<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Welcome to the mysterious world</title>
    <link>https://ly19911114.github.io/</link>
    <description>Recent content on Welcome to the mysterious world</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 01 Mar 2020 15:44:42 +0800</lastBuildDate>
    
	<atom:link href="https://ly19911114.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>SpringCloud的学习总结</title>
      <link>https://ly19911114.github.io/post/springcloud%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 01 Mar 2020 15:44:42 +0800</pubDate>
      
      <guid>https://ly19911114.github.io/post/springcloud%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</guid>
      <description>一、CAP的理论 CAP定理： 指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可同时获得。
 一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（所有节点在同一时间的数据完全一致，越多节点，数据同步越耗时）  ​
可用性（A）：负载过大后，集群整体是否还能响应客户端的读写请求。（服务一直可用，而且是正常响应时间）
 分区容错性（P）：分区容忍性，就是高可用性，一个节点崩了，并不影响其它的节点（100个节点，挂了几个，不影响服务，越多机器越好） CAP理论就是说在分布式存储系统中，最多只能实现上面的两点。而由于当前的网络硬件肯定会出现延迟丢包等问题，所以分区容忍性是我们必须需要实现的。所以我们只能在一致性和可用性之间进行权衡  二、利用ribbiton在各个服务之间进行调用 例子：订单信息调用商品信息，代码如下
 首先在订单服务的启动类里面加入注解和ResTemplate
@Bean @LoadBalanced public RestTemplate restTemplate() { return new RestTemplate(); }  订单服务调用商品服务的接口，采用HTTP协议
  Map productMap = restTemplate.getForObject(&amp;ldquo;http://product-service/api/v1/product/find?id=&amp;quot;+productId, Map.class)&amp;mdash;》获取到商品服务的信息
 package net.xdclass.order_service.service.impl; import net.xdclass.order_service.domain.ProductOrder; import net.xdclass.order_service.service.ProductOrderService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.cloud.client.ServiceInstance; import org.springframework.cloud.client.loadbalancer.LoadBalancerClient; import org.springframework.stereotype.Service; import org.springframework.web.client.RestTemplate; import sun.net.www.URLConnection; import sun.net.www.http.HttpClient; import java.util.Date; import java.util.Map; import java.util.UUID; @Service public class ProductOrderServiceImpl implements ProductOrderService { @Autowired private RestTemplate restTemplate; @Override public ProductOrder save(int userId, int productId) { Map&amp;lt;String,Object&amp;gt; productMap = restTemplate.</description>
    </item>
    
    <item>
      <title>一级缓存和二级缓存的区别练习</title>
      <link>https://ly19911114.github.io/post/mybatis-%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E5%92%8C%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E7%9A%84%E5%8C%BA%E5%88%AB%E7%BB%83%E4%B9%A0/</link>
      <pubDate>Mon, 24 Feb 2020 11:18:49 +0800</pubDate>
      
      <guid>https://ly19911114.github.io/post/mybatis-%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E5%92%8C%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E7%9A%84%E5%8C%BA%E5%88%AB%E7%BB%83%E4%B9%A0/</guid>
      <description>Mybatis 为我们提供了一级缓存和二级缓存，可以通过下图来理解：
①、一级缓存是SqlSession级别的缓存。在操作数据库时需要构造sqlSession对象，在对象中有一个数据结构（HashMap）用于存储缓存数据。不同的sqlSession之间的缓存数据区域（HashMap）是互相不影响的。
②、二级缓存是mapper级别的缓存，多个SqlSession去操作同一个Mapper的sql语句，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。
1、一级缓存
①、我们在一个 sqlSession 中，对 User 表根据id进行两次查询，查看他们发出sql语句的情况。
@Test
public void testSelectOrderAndUserByOrderId(){
​ //根据 sqlSessionFactory 产生 session
​ SqlSession sqlSession = sessionFactory.openSession();
​ String statement = &amp;ldquo;one.to.one.mapper.OrdersMapper.selectOrderAndUserByOrderID&amp;rdquo;;
​ UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
​ //第一次查询，发出sql语句，并将查询的结果放入缓存中
​ User u1 = userMapper.selectUserByUserId(1);
​ System.out.println(u1);
​ //第二次查询，由于是同一个sqlSession,会在缓存中查找查询结果
​ //如果有，则直接从缓存中取出来，不和数据库进行交互
​ User u2 = userMapper.selectUserByUserId(1);
​ System.out.println(u2);
​ sqlSession.close();
}
查看控制台打印情况：
②、 同样是对user表进行两次查询，只不过两次查询之间进行了一次update操作。
@Test
public void testSelectOrderAndUserByOrderId(){
​ //根据 sqlSessionFactory 产生 session
​ SqlSession sqlSession = sessionFactory.</description>
    </item>
    
    <item>
      <title>Linux虚拟机安装Redis和碰到的问题</title>
      <link>https://ly19911114.github.io/post/linux%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85redis%E5%92%8C%E7%A2%B0%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Thu, 20 Feb 2020 01:09:32 +0800</pubDate>
      
      <guid>https://ly19911114.github.io/post/linux%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85redis%E5%92%8C%E7%A2%B0%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>1、解决could not retrieve mirrorlist，
 1.sudo 2.sudo su用sudo命令进入管理员账号 vim /etc/sysconfig/network-scripts/ifcfg-ens33 (不一定是ens33，要看清楚自己的文件名字)  　3.将ONBOOT改为yes，wq!保存退出
 4.重新启动网络 $ service network restart  ​
2、 安装wget yum install wget
​
3、 下载redis安装包
 wget http://download.redis.io/releases/redis-4.0.6.tar.gz  ​
4、 解压压缩包
 tar zxvf redis-4.0.6.tar.gz  ​
5、yum install gcc
​
6、跳转到redis解压目录下 cd redis-4.0.6
​
7、编译安装 make MALLOC=libc　 8、cd src &amp;amp;&amp;amp; make install 9、测试是否安装成功 ./redis-server  </description>
    </item>
    
    <item>
      <title>微服务SpringCloud和Docker知识点详解</title>
      <link>https://ly19911114.github.io/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1springcloud%E5%92%8Cdocker%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Tue, 18 Feb 2020 16:26:31 +0800</pubDate>
      
      <guid>https://ly19911114.github.io/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1springcloud%E5%92%8Cdocker%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AF%A6%E8%A7%A3/</guid>
      <description>=============================================
SpringCloud课程笔记.txt
第一章 课程介绍和学习路线 1、微服务架构SpringCloud课程介绍 简介：课程介绍和课程大纲讲解，讲课风格和重点内容理解技巧
2、技术选型和学后水平 简介：课程所需基础和技术选型讲解，学完课程可以到达怎样的程度，
1、IDEA JDK8 Maven SpringBoot基础 Linux 2、理解掌握并开发SpringCloud里面主流架构和组件的基础使用，还有部分源码原理的理解 3、掌握学习的技巧和解决问题的思路  第二章 架构演进和分布式系统基础知识 1、传统架构演进到分布式架构 简介：讲解单机应用和分布式应用架构演进基础知识 (画图)
 高可用 LVS+keepalive 1、单体应用： 开发速度慢 启动时间长 依赖庞大 等等 2、微服务 易开发、理解和维护 独立的部署和启动 等 不足： 分布式系统-》分布式事务问题 需要管理多个服务-》服务治理  2、微服务核心基础讲解 简介：讲解微服务核心知识 ：网关、服务发现注册、配置中心、链路追踪、负载均衡器、熔断 1、网关：路由转发 + 过滤器 /api/v1/pruduct/ 商品服务 /api/v1/order/ 订单服务 /api/v1/user/ 用户服务
 2、服务注册发现：调用和被调用方的信息维护 3、配置中心：管理配置，动态更新 application.properties 4、链路追踪：分析调用链路耗时 例子：下单-》查询商品服务获取商品价格-》查询用户信息-》保存数据库 5、负载均衡器：分发负载 6、熔断：保护自己和被调用方  3、常见的微服务框架 简介:讲解常用的微服务框架
 consumer: 调用方 provider: 被调用方 一个接口一般都会充当两个角色（不是同时充当） 1、dubbo: zookeeper + dubbo + springmvc/springboot 官方地址：http://dubbo.</description>
    </item>
    
    <item>
      <title>Shiro的复盘</title>
      <link>https://ly19911114.github.io/post/shiro%E7%9A%84%E5%A4%8D%E7%9B%98/</link>
      <pubDate>Wed, 12 Feb 2020 20:42:30 +0800</pubDate>
      
      <guid>https://ly19911114.github.io/post/shiro%E7%9A%84%E5%A4%8D%E7%9B%98/</guid>
      <description>一、前言 智慧微仓项目用Shiro添加权限认证，目前已按照业务需求，完成，现在进行总结复盘，主要以代码为主，详细的教程在之前的文章有写，请转到文章&amp;rdquo;shiro权限与SpringBoot整合的知识点&amp;rdquo;。
二、自定义Realm 配置这里不再赘述，注意包不要导错，自定义的Realm要继承Shiro的AuthorizingRealm；包括授权和登录验证
package com.jeehome.micro.warehouse.config; import com.jeehome.micro.warehouse.entity.PermissionEntity; import com.jeehome.micro.warehouse.entity.RoleEntity; import com.jeehome.micro.warehouse.entity.UserEntity; import com.jeehome.micro.warehouse.service.UserService; import org.apache.shiro.authc.AuthenticationException; import org.apache.shiro.authc.AuthenticationInfo; import org.apache.shiro.authc.AuthenticationToken; import org.apache.shiro.authc.SimpleAuthenticationInfo; import org.apache.shiro.authz.AuthorizationInfo; import org.apache.shiro.authz.SimpleAuthorizationInfo; import org.apache.shiro.realm.AuthorizingRealm; import org.apache.shiro.subject.PrincipalCollection; import org.springframework.beans.factory.annotation.Autowired; import java.util.ArrayList; import java.util.List; /** * 自定义realm */ public class CustomRealm extends AuthorizingRealm { @Autowired private UserService userService; /** * 进行权限校验的时候调用 * * @param principals * @return */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) { System.out.println(&amp;quot;授权 doGetAuthorizationInfo&amp;quot;); //获取用户名 String userName = (String) principals.</description>
    </item>
    
    <item>
      <title>Springboot与shiro的具体项目</title>
      <link>https://ly19911114.github.io/post/springboot%E4%B8%8Eshiro%E7%9A%84%E5%85%B7%E4%BD%93%E9%A1%B9%E7%9B%AE/</link>
      <pubDate>Mon, 06 Jan 2020 15:43:28 +0800</pubDate>
      
      <guid>https://ly19911114.github.io/post/springboot%E4%B8%8Eshiro%E7%9A%84%E5%85%B7%E4%BD%93%E9%A1%B9%E7%9B%AE/</guid>
      <description></description>
    </item>
    
    <item>
      <title>SVN分支创建和主干代码的合并问题</title>
      <link>https://ly19911114.github.io/post/svn%E5%88%86%E6%94%AF%E5%88%9B%E5%BB%BA%E5%92%8C%E4%B8%BB%E5%B9%B2%E4%BB%A3%E7%A0%81%E7%9A%84%E5%90%88%E5%B9%B6%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 30 Dec 2019 16:34:24 +0800</pubDate>
      
      <guid>https://ly19911114.github.io/post/svn%E5%88%86%E6%94%AF%E5%88%9B%E5%BB%BA%E5%92%8C%E4%B8%BB%E5%B9%B2%E4%BB%A3%E7%A0%81%E7%9A%84%E5%90%88%E5%B9%B6%E9%97%AE%E9%A2%98/</guid>
      <description>最近项目中涉及到了SVN的创建分支，以及分支和主干代码的合并。在此记录一下主要的东西（恩，感觉这位博主的截图好暖心，就忍不住转一下了）~
一、创建分支的意义： 在日常项目开发及版本迭代的过程中，经常会遇到这样的场景：当前版本提交QA测试之后，一方面需要在主干上开发下一版本的新需求；另一方面还需要在新的分支上解决QA提的Bug。项目上线之后，需要将分支上的改动合并到主干上。这就需要需要我们熟练掌握分支开发及合并。
二、创建新分支的步骤  创建测试项目并使其和SVN进行关联： 首先我们在Android Studio中新建一个测试项目SVNTestDemo，然后使其和SVN进行关联（从SVN更新下来的项目可忽略此步，不熟悉此步骤的朋友们请请转至 上一篇）。 提交本地新增或改变的文件：创建新分支前，最好先将本地修改的文件提交至 SVN。SVN 每一次提交操作时，都会有一个对应的 Revision。这里我们需要记住创建分支前最后一次提交修改文件时，该操作对应的 Revision（非常重要），以供后续合并分支时使用。 创建新分支：将项目切换至Project目录，选中项目后点击右键，依次选择Subversion-&amp;gt;Branch or Tag 如下图所示： 之后会弹出如下弹框： 可根据需要选择拷贝源、新分支目录、修改分支项目文件名等。然后填写Comment，点击OK。分支创建成功后，在SVN仓库branches目录对应的文件下，右键选择 SVN Update 拉取分支代码。如下图所示： 双击打开 branches 文件夹，然后右键选择 SVN Update 拉取分支代码： 拉取成功后，branches文件目录下会出现一个新的文件夹new_branch。至此，新分支创建彻底完成。  三、对主干和分支进行相互合并： 为方便测试，我们首先分别对分支和主干的文件进行修改并提交（仅供测试使用，实际项目中只有主干和分支文件或代码不相同时才需要合并）。合并之前需要先更新一下代码，保证目标分支本地的代码是最新的，避免不必要的冲突。
1. 将分支的改动合并到主干： 在Android Studio中打开主干项目，切换至Project目录，选中项目并点击右键，依次选择Subversion-&amp;gt; Integrate Directory 如下图所示： 之后会弹出如下弹框： 注意（此处有坑！！！）：从上图可以看出合并时，Revision默认选中的都是HEAD（即：最新版），此时若点击OK，主干新创建的类会被删除，主干和分支同时修改的类会被分支覆盖，主干中的文件及其内容将变成和分支一模一样；
显然大多时候这并不是我们想要的，我们需要保留主干的新增文件，同时合并分支的改动。这时主干（即：Source 1）的 Revision就不应该是最新版 HEAD，而是之前我们所说的 创建分支前最后一次提交修改时，该操作所对应的 Revision。
获取该Revision的方式：选中Source 1右侧的Revision为Specified，然后点击其右侧的 … 按钮，弹出如下弹框： 从图中我们可以看到之前的提交记录，我们选中Revision 4，然后点击 OK 即可。
通过上面方式，修改分支合并时的配置页如下： 点击OK，解决合并时的冲突。运行无异常后，提交合并后的文件至SVN即可。
2. 将主干的改动合并到分支： 首先在Android Studio中打开分支项目，从SVN更新代码，保证分支对应的本地代码是最新的。 从主干合并至分支时的其他过程与上述合并过程基本一致，只需将合并配置页的Source 1和Source 2对应的分支路径进行调换，Source 1（即：分支路径）对应的Revision选择创建该分支时，该操作所对应的Revision即可。 点击OK，解决合并时的冲突。运行无异常后，提交合并后的文件至SVN即可。
（注意，将分支合并到主干上后，svn show log日志上是没有日志记录的，只有再次点击提交主干代码后，才会有日志记录哈~）</description>
    </item>
    
    <item>
      <title>List集合去除重复对象</title>
      <link>https://ly19911114.github.io/post/list%E9%9B%86%E5%90%88%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Mon, 30 Dec 2019 10:18:24 +0800</pubDate>
      
      <guid>https://ly19911114.github.io/post/list%E9%9B%86%E5%90%88%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%AF%B9%E8%B1%A1/</guid>
      <description>引言
最近公司的中间件的中转后台中需要用到List集合去除重复对象这一技术点，下面，由浅入深的进行讲解开展。
再分析代码之前，先来了解下equal和hashcode，因为要去除List重复对象，需要在实体类中重写这两个方法，先来了解这两个方法，更有助于理解代码。
Now,Let is go(Let is 懒的缩写了，这不重要！！)
内容比较冗长，还请耐心看完。
一、项目中为何要重写equals和hashcode方法。 equals()方法在object类中定义如下：
public boolean equals(Object obj) { return (this == obj); }  很明显是对两个对象的地址值进行的比较（即比较引用是否相同）。但是我们知道，String 、Math、Integer、Double等这些封装类在使用equals()方法时，已经覆盖了object类的equals()方法。
hashcode()方法在object类中的定义如下：
public native int hashCode();  hashCode()方法给对象返回一个hash code值。这个方法被用于hash tables，例如HashMap。
它的性质是：
在一个Java应用的执行期间，如果一个对象提供给equals做比较的信息没有被修改的话，该对象多次调用hashCode()方法，该方法必须始终如一返回同一个integer。
如果两个对象根据equals(Object)方法是相等的，那么调用二者各自的hashCode()方法必须产生同一个integer结果。
并不要求根据equals(java.lang.Object)方法不相等的两个对象，调用二者各自的hashCode()方法必须产生不同的integer结果。然而，程序员应该意识到对于不同的对象产生不同的integer结果，有可能会提高hash table的性能。
大量的实践表明，由Object类定义的hashCode()方法对于不同的对象返回不同的integer。
hashCode()方法和equal()方法的作用其实一样，在Java里都是用来对比两个对象是否相等一致，那么equal()既然已经能实现对比的功能了，为什么还要hashCode()呢？
​ 因为重写的equal（）里一般比较的比较全面比较复杂，这样效率就比较低，而利用hashCode()进行对比，则只要生成一个hash值进行比较就可以了，效率很高，那么hashCode()既然效率这么高为什么还要equal()呢？
​ 因为hashCode()并不是完全可靠，有时候不同的对象他们生成的hashcode也会一样（生成hash值得公式可能存在的问题），所以hashCode()只能说是大部分时候可靠，并不是绝对可靠，所以我们可以得出：
​ 1.equal()相等的两个对象他们的hashCode()肯定相等，也就是用equal()对比是绝对可靠的。
​ 2.hashCode()相等的两个对象他们的equal()不一定相等，也就是hashCode()不是绝对可靠的。
​ 所有对于需要大量并且快速的对比的话如果都用equal()去做显然效率太低，所以解决方式是，每当需要对比的时候，首先用hashCode()去对比，如果hashCode()不一样，则表示这两个对象肯定不相等（也就是不必再用equal()去再对比了）,如果hashCode()相同，此时再对比他们的equal()，如果equal()也相同，则表示这两个对象是真的相同了，这样既能大大提高了效率也保证了对比的绝对正确性！
然而hashCode()和equal()一样都是基本类Object里的方法，而和equal()一样，Object里hashCode()里面只是返回当前对象的地址，如果是这样的话，那么我们相同的一个类，new两个对象，由于他们在内存里的地址不同，则他们的hashCode（）不同，所以这显然不是我们想要的，所以我们必须重写我们类的hashCode()方法，即一个类，在hashCode()里面返回唯一的一个hash值。
综上所述，在实际项目中，根据也无需求，必须要重写equals和hashcode方法。
二、如何进行List对象的去除操作 首先要在实体类中重写equals()和hashcode()方法，至于为什么要重新，请参考标题一，下面是项目中 RfidGoodsResponse实体类的实际代码：
public class RfidGoodsResponse { private String goodsName; private int goodsNum; private Integer goodsId; public Integer getGoodsId() { return goodsId; } public void setGoodsId(Integer goodsId) { this.</description>
    </item>
    
    <item>
      <title>SpringBoot中的@Configuration注解和@Bean注解</title>
      <link>https://ly19911114.github.io/post/springboot%E4%B8%AD%E7%9A%84configuration%E6%B3%A8%E8%A7%A3%E5%92%8Cbean%E6%B3%A8%E8%A7%A3/</link>
      <pubDate>Mon, 23 Dec 2019 23:38:03 +0800</pubDate>
      
      <guid>https://ly19911114.github.io/post/springboot%E4%B8%AD%E7%9A%84configuration%E6%B3%A8%E8%A7%A3%E5%92%8Cbean%E6%B3%A8%E8%A7%A3/</guid>
      <description>@Configuration
1.@Configuration注解底层是含有@Component ，所以@Configuration 具有和 @Component 的作用。
2.@Configuration注解相当于spring的xml配置文件中标签，里面可以配置bean。
&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt; &amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot; xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&amp;quot;&amp;gt; &amp;lt;!--实例化一个Person对象--&amp;gt; &amp;lt;bean id=&amp;quot;person&amp;quot; class=&amp;quot;com.sff.app.bean.Person&amp;quot;/&amp;gt; &amp;lt;/beans&amp;gt;  那么@Configuration注解就相当于我们的spring-bean.xml文件中的&amp;hellip;&amp;hellip;，它可以这样使用。
/** * 配置类等价于spring-bean.xml文件 */ @Configuration public class AppConfig { }  @Bean
1.@Bean注解相当于spring的xml配置文件标签，告诉容器注入一个bean。
2.@Bean注解的方法上如果没通过bean指定实例名，默认实例名与方法名相同。
3.@Bean注解默认为单例模式，可以通过@Scope(&amp;ldquo;prototype&amp;rdquo;)设置为多例。
/** * 配置类等价于spring-bean.xml文件 */ @Configuration public class AppConfig { /*给容器中注册一个bean,类型是方法返回值，id就是方法名称*/ @Bean public Person person() { return new Person(&amp;quot;Kate&amp;quot;, 12); } }  </description>
    </item>
    
    <item>
      <title>Shiro权限与SpringBoot整合</title>
      <link>https://ly19911114.github.io/post/shiro%E6%9D%83%E9%99%90%E4%B8%8Espringboot%E6%95%B4%E5%90%88%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/</link>
      <pubDate>Mon, 23 Dec 2019 22:50:45 +0800</pubDate>
      
      <guid>https://ly19911114.github.io/post/shiro%E6%9D%83%E9%99%90%E4%B8%8Espringboot%E6%95%B4%E5%90%88%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/</guid>
      <description>title: &amp;ldquo;shiro权限框架与SpringBoot的整合&amp;rdquo; date: 2019-12-22T16:28:13+08:00 draft: true
近期在学习shiro的权限框架，整理资料如下：包括基本概念，单元测试，SpringBoot整合shiro框架的实操，最后是上线项目的整合
第1章 Shiro权限实战课程介绍 第1集 Shiro权限实战课程介绍 简介：讲解为什么要学这门课，Shiro权限框架的课程大纲和学后水平
 公司新项目需要用到、要么就是需要接收别人的代码、个人技术栈的成长 Springboot2.x/SpringMVC + Maven + jdk8 + IDEA/Eclipse
 学后水平：掌握Shiro在公司中实际的使用，包括明白里面的核心原理
  第2集 权限控制和初学JavaWeb处理访问权限控制 简介：讲解什么是权限控制，初学JavaWeb时处理流程
 什么是权限控制：  忽略特别细的概念，比如权限能细分很多种，功能权限，数据权限，管理权限等 理解两个概念：用户和资源，让指定的用户，只能操作指定的资源（CRUD）  初学javaweb时怎么做
 Filter接口中有一个doFilter方法，自己编写好业务Filter，并配置对哪个web资源进行拦截后 如果访问的路径命中对应的Filter，则会执行doFilter()方法，然后判断是否有权限进行访问对应的资源 /api/user/info?id=1
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws Exception { HttpServletRequest httpRequest=(HttpServletRequest)request; HttpServletResponse httpResponse=(HttpServletResponse)response; HttpSession session=httpRequest.getSession(); if(session.getAttribute(&amp;quot;username&amp;quot;)!=null){ chain.doFilter(request, response); } else { httpResponse.sendRedirect(httpRequest.getContextPath()+&amp;quot;/login.jsp&amp;quot;); } }    第2章 大话权限框架核心知识ACL和RBAC 第1集 权限框架设计之ACL和RBAC讲解 简介：介绍什么是ACL和RBAC</description>
    </item>
    
    <item>
      <title>Springboot项目规范总结</title>
      <link>https://ly19911114.github.io/post/springboot%E9%A1%B9%E7%9B%AE%E8%A7%84%E8%8C%83%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 22 Dec 2019 16:28:13 +0800</pubDate>
      
      <guid>https://ly19911114.github.io/post/springboot%E9%A1%B9%E7%9B%AE%E8%A7%84%E8%8C%83%E6%80%BB%E7%BB%93/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>