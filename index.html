<!DOCTYPE html>
<html lang="en-us">
<head prefix="og: http://ogp.me/ns#">
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />
  <meta property="og:title" content=" Welcome to the mysterious world" />
  
  <meta property="og:site_name" content="Welcome to the mysterious world" />
  <meta property="og:url" content="https://ly19911114.github.io/" />
  
  
  <meta property="og:type" content="website" />
  

  <title>
     Welcome to the mysterious world
  </title>

  <link rel="stylesheet" href="https://ly19911114.github.io/css/bootstrap.min.css" />
  <link rel="stylesheet" href="https://ly19911114.github.io/css/main.css" />
  <link rel="stylesheet" href="https://ly19911114.github.io/css/font-awesome.min.css" />
  <link rel="stylesheet" href="https://ly19911114.github.io/css/github.css" />
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400" type="text/css">
  <link rel="shortcut icon" href="https://ly19911114.github.io/images/favicon.ico" />
  <link rel="apple-touch-icon" href="https://ly19911114.github.io/images/apple-touch-icon.png" />
  
  <link href="https://ly19911114.github.io/index.xml" rel="alternate" type="application/rss+xml" title="Welcome to the mysterious world" />
  
</head>
<body>
    <header class="global-header"  style="background-image:url( /images/bg.jpg )">
    <section class="header-text">
      <h1><a href="https://ly19911114.github.io/">Welcome to the mysterious world</a></h1>
      
      <div class="sns-links hidden-print">
  
  
  
  
  
  
  
  
  
  
  
  
</div>

      
      
      <a href="https://ly19911114.github.io/index.xml" class="btn-header btn-subscribe hidden-xs">
        <i class="fa fa-rss" aria-hidden="true"></i>
        &nbsp;Subscribe
      </a>
      
    </section>
  </header>
  <main class="container">

<div class="article-list">
  
  
  <article>
  <header>
    <h2><a href="https://ly19911114.github.io/post/%E8%A7%A3%E5%86%B3idea%E6%BA%90%E7%A0%81%E6%B2%A1%E6%9C%89%E6%B3%A8%E9%87%8A/">解决IDEA源码没有注释</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2020-04-10T16:31:53&#43;08:00">
          Apr 10, 2020
        </time>
      </div>
    </div>
  </header>
  <div>
    当你的源码没有注释，但又想阅读注解，Download Sources也无效的时候，试试我这招，百试百灵，千言万语汇成一句话：在IDEA工具界面的左下角，有个点击Terminal，输入命令：mvn dependency:resolve -Dclassifier=sources，然后再点击Download Sources，OK，大功告成！
  </div>
  
</article>

  
  
  <hr/>
  
  <article>
  <header>
    <h2><a href="https://ly19911114.github.io/post/mybatis%E4%B8%ADlike%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2/">Mybatis中Like模糊查询</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2020-04-06T22:06:48&#43;08:00">
          Apr 6, 2020
        </time>
      </div>
    </div>
  </header>
  <div>
    模糊查询在项目中还是经常使用的，本文就简单整理Mybatis中使用Like进行模糊查询的几种写法以及一些常见的问题。
使用Springboot简单配置一下Mybatis，然后进行说明。Springboot集成Mybatis这里就不做介绍了。
初始数据 方式一 在Mybatis中的第一种写法：
&lt;!--有sql注入问题--&gt; &lt;select id=&quot;findUserByLikeName1&quot; parameterType=&quot;java.lang.String&quot; resultMap=&quot;user&quot;&gt; select * from t_user where name like '%${name}%' &lt;/select&gt;  这种会有sql注入的问题，需要明白在 Mybatis中 $ 和 # 使用的区别。这种写法也不能加jdbcType=VARCHAR,否则也会报错。
做了个简单的测试：
@Test public void findUserByLikeName1(){ List&lt;User&gt; test = userMapper.findUserByLikeName1(&quot;Cloud&quot;); //select * from t_user where name like '%Cloud%' System.out.println(test.size());// 查出一条 List&lt;User&gt; test1 = userMapper.findUserByLikeName1(&quot;' or '1=1&quot;); //select * from t_user where name like '%' or '1=1%' // 分析： '1=1%' 成立 System.out.println(test1.size());// 查出了全部数据 }  注意：排序的字段也容易出现这个问题，在使用的时候也一定要注意。
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://ly19911114.github.io/post/mybatis%E4%B8%ADlike%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
  
  <hr/>
  
  <article>
  <header>
    <h2><a href="https://ly19911114.github.io/post/%E6%B3%9B%E5%9E%8B%E8%AF%A6%E8%A7%A3/">泛型详解</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2020-04-04T11:46:14&#43;08:00">
          Apr 4, 2020
        </time>
      </div>
    </div>
  </header>
  <div>
    对java的泛型特性的了解仅限于表面的浅浅一层，直到在学习设计模式时发现有不了解的用法，才想起详细的记录一下。 本文参考java 泛型详解、Java中的泛型方法、 java泛型详解  1. 概述 泛型在java中有很重要的地位，在面向对象编程及各种设计模式中有非常广泛的应用。
什么是泛型？为什么要使用泛型？

泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。 泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。  
2. 一个栗子 一个被举了无数次的例子：

List arrayList = new ArrayList(); arrayList.add(&quot;aaaa&quot;); arrayList.add(100); for(int i = 0; i&lt; arrayList.size();i++){ String item = (String)arrayList.get(i); Log.d(&quot;泛型测试&quot;,&quot;item = &quot; + item); }  
毫无疑问，程序的运行结果会以崩溃结束：
java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String  ArrayList可以存放任意类型，例子中添加了一个String类型，添加了一个Integer类型，再使用时都以String的方式使用，因此程序崩溃了。为了解决类似这样的问题（在编译阶段就可以解决），泛型应运而生。
我们将第一行声明初始化list的代码更改一下，编译器会在编译阶段就能够帮我们发现类似这样的问题。
List&lt;String&gt; arrayList = new ArrayList&lt;String&gt;(); ... //arrayList.add(100); 在编译阶段，编译器就会报错  3. 特性 泛型只在编译阶段有效。看下面的代码：

List&lt;String&gt; stringArrayList = new ArrayList&lt;String&gt;(); List&lt;Integer&gt; integerArrayList = new ArrayList&lt;Integer&gt;(); Class classStringArrayList = stringArrayList.
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://ly19911114.github.io/post/%E6%B3%9B%E5%9E%8B%E8%AF%A6%E8%A7%A3/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
  
  <hr/>
  
  <article>
  <header>
    <h2><a href="https://ly19911114.github.io/post/%E6%B3%A8%E8%A7%A3data%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/">注解@Data的使用说明</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2020-04-01T21:53:48&#43;08:00">
          Apr 1, 2020
        </time>
      </div>
    </div>
  </header>
  <div>
    @Data 注解的主要作用是提高代码的简洁，使用这个注解可以省去代码中大量的get()、 set()、 toString()等方法；
引入lombok 要使用 @Data 注解要先引入lombok，lombok 是什么，它是一个工具类库，可以用简单的注解形式来简化代码，提高开发效率。
 在maven中添加依赖
&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.4&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt;  在编译器中添加插件 这里以IDEA为例，在setting的plugin里搜索lombok plugin，安装插件。
  使用 直接在相应的实体类上加上@Data注解即可；
比如一个简单的Person类，用常规的写法：
public class Person { private String name; private String address; private Integer age; private String hobbit; private String phone; public Person() { } public Person(String name, String address, Integer age, String hobbit, String phone) { this.name = name; this.address = address; this.age = age; this.
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://ly19911114.github.io/post/%E6%B3%A8%E8%A7%A3data%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
  
  <hr/>
  
  <article>
  <header>
    <h2><a href="https://ly19911114.github.io/post/%E5%85%B3%E4%BA%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">关于设计模式</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2020-03-27T00:01:55&#43;08:00">
          Mar 27, 2020
        </time>
      </div>
    </div>
  </header>
  <div>
    最近在读《Heade First设计模式》一书，收获颇多，代码放在GitHub仓库上，下载地址：https://github.com/ly19911114/design-mode.git
  </div>
  
</article>

  
  
  <hr/>
  
  <article>
  <header>
    <h2><a href="https://ly19911114.github.io/post/existinnot/">Exist,in;not</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2020-03-22T18:48:26&#43;08:00">
          Mar 22, 2020
        </time>
      </div>
    </div>
  </header>
  <div>
    in 是把外表和内表作hash join，而exists是对外表作loop，每次loop再对内表进行查询。一般大家都认为exists比in语句的效率要高，这种说法其实是不准确的，这个是要区分环境的。
exists对外表用loop逐条查询，每次查询都会查看exists的条件语句，当 exists里的条件语句能够返回记录行时(无论记录行是的多少，只要能返回)，条件就为真，返回当前loop到的这条记录，反之如果exists里的条件语句不能返回记录行，则当前loop到的这条记录被丢弃，exists的条件就像一个bool条件，当能返回结果集则为true，不能返回结果集则为 false。
例如：
select * from user where exists (select 1);
对user表的记录逐条取出，由于子条件中的select 1永远能返回记录行，那么user表的所有记录都将被加入结果集，所以与 select * from user;是一样的
又如下
select * from user where exists (select * from user where userId = 0);
可以知道对user表进行loop时，检查条件语句(select * from user where userId = 0),由于userId永远不为0，所以条件语句永远返回空集，条件永远为false，那么user表的所有记录都将被丢弃
not exists与exists相反，也就是当exists条件有结果集返回时，loop到的记录将被丢弃，否则将loop到的记录加入结果集
总的来说，如果A表有n条记录，那么exists查询就是将这n条记录逐条取出，然后判断n遍exists条件
in查询相当于多个or条件的叠加，这个比较好理解，比如下面的查询
select * from user where userId in (1, 2, 3);
等效于
select * from user where userId = 1 or userId = 2 or userId = 3;
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://ly19911114.github.io/post/existinnot/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
  
  <hr/>
  
  <article>
  <header>
    <h2><a href="https://ly19911114.github.io/post/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8Cab%E4%BB%BB%E5%8A%A1%E7%9A%84%E7%AD%89%E5%BE%85%E5%90%8C%E6%AD%A5/">多线程执行AB任务的等待同步</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2020-03-18T00:24:04&#43;08:00">
          Mar 18, 2020
        </time>
      </div>
    </div>
  </header>
  <div>
    内容描述： 在多线程中，有两个任务A与B，多线程执行任务A完成后再继续执行任务B，想到的两种方法一种线程间通信，使用条件变量方式，第二种就是使用CountDownLatch。
条件变量 主要使用的条件变量，判断是否任务Ａ已经做完，然后再执行任务Ｂ  public class Main { public static boolean[] flag = new boolean[3]; public static boolean judge(boolean[] f) { for (int i = 0; i &lt; f.length; i++) { if (!f[i]) { return false; } } return true; } public static void main(String[] args) { for (int i = 0; i &lt; flag.length; i++) { flag[i] = false; } new Thread(new Runnable() { public void run() { while (true) { if (!
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://ly19911114.github.io/post/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8Cab%E4%BB%BB%E5%8A%A1%E7%9A%84%E7%AD%89%E5%BE%85%E5%90%8C%E6%AD%A5/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
  
  <hr/>
  
  <article>
  <header>
    <h2><a href="https://ly19911114.github.io/post/java%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/">Java集合类线程安全问题以及解决办法</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2020-03-07T15:08:23&#43;08:00">
          Mar 7, 2020
        </time>
      </div>
    </div>
  </header>
  <div>
    一、List 1.1 模拟多线程环境 ​ 多线程环境下，会抛出 java.util.ConcurrentModificationException 异常
public static void listNotSafe() { List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 30; i++) { new Thread(() -&gt; { list.add(UUID.randomUUID().toString().substring(0, 8)); System.out.println(list); }).start(); } }  1.2 异常原因  多线程环境下，并发争抢修改导致出现该异常。  1.3 解决办法 // 1. 使用线程安全类 Vector new Vector(); // 2. 使用 Collections 工具类封装 ArrayList Collections.synchronizedList(new ArrayList&lt;&gt;()); // 3. 使用 java.util.concurrent.CopyOnWriteArrayList; new CopyOnWriteArrayList&lt;&gt;();  1.4 写时复制思想 CopyOnWrite 容器即写时复制的容器。往一个容器添加元素的时候，不直接往当前容器Object[]添加，而是先将当前容器Object[]进行Copy, 复制出一个新的容器Object[] newElements， 然后新的容器Object[] newElements 里添加元素，添加完元素之后，再将原容器的引用指向新的容器 setArray(newElements); 这样做的好处是可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。  // CopyOnWriteArrayList.
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://ly19911114.github.io/post/java%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
  
  <hr/>
  
  <article>
  <header>
    <h2><a href="https://ly19911114.github.io/post/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/">字符串常量池深入理解</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2020-03-07T13:36:23&#43;08:00">
          Mar 7, 2020
        </time>
      </div>
    </div>
  </header>
  <div>
    一、概述 在分析字符串常量池之前，先来分析一下java的内存区域，然后再各种的情况分析一下各种情况下的情况；
在《深入理解java虚拟机》这本书上是这样写的：对于HotSpot虚拟机，根据官方发布的路线图信息，现在也有放弃永久代并逐步的改为采用Native Memory来实现方法区的规划了，在目前已经发布的JDK1.7的HotSpot中，已经把原来存放在方法区中的字符串常量池移出。根据查阅的资料显示在JDK1.7以后的版本中字符串常量池移到堆内存区域；同时在jdk1.8中移除整个永久代，取而代之的是一个叫元空间（Metaspace）的区域
在 JAVA 语言中有8中基本类型和一种比较特殊的类型String。这些类型为了使他们在运行过程中速度更快，更节省内存，都提供了一种常量池的概念。常量池就类似一个JAVA系统级别提供的缓存。
8种基本类型的常量池都是系统协调的，String类型的常量池比较特殊。它的主要使用方法有两种：
 直接使用双引号声明出来的String对象会直接存储在常量池中。 如果不是用双引号声明的String对象，可以使用String提供的intern方法。intern 方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中  二、Java中两种创建字符串对象的方法的分析
String s1 = &quot;abc&quot;; String s2 = &quot;abc&quot;; System.out.println(s1==s2);  结果是 true；
采用字面值的方式创建一个字符串时，JVM首先会去字符串池中查找是否存在&rdquo;abc&rdquo;这个对象，如果不存在，则在字符串常量池中创建&rdquo;abc&rdquo;这个对象，然后将池中&rdquo;abc&rdquo;这个对象的引用地址返回给&rdquo;abc&rdquo;对象的引用s1，这样s1会指向字符串常量池中&rdquo;abc&rdquo;这个字符串对象；如果存在，则不创建任何对象，直接将池中&rdquo;abc&rdquo;这个对象的地址返回，赋给引用s2。因为s1、s2都是指向同一个字符串池中的&rdquo;abc&rdquo;对象，所以结果为true。
String s3 = new String(&quot;xyz&quot;); String s4 = new String(&quot;xyz&quot;); System.out.println(s3==s4);  结果是 false
采用new关键字新建一个字符串对象时，JVM首先在字符串池中查找有没有&rdquo;xyz&rdquo;这个字符串对象，如果有，则不在池中再去创建&rdquo;xyz&rdquo;这个对象了，直接在堆中创建一个&rdquo;xyz&rdquo;字符串对象，然后将堆中的这个&rdquo;xyz&rdquo;对象的地址返回赋给引用s3，这样，s3就指向了堆中创建的这个&rdquo;xyz&rdquo;字符串对象；如果没有，则首先在字符串池中创建一个&rdquo;xyz&rdquo;字符串对象，然后再在堆中创建一个&rdquo;xyz&rdquo;字符串对象，然后将堆中这个&rdquo;xyz&rdquo;字符串对象的地址返回赋给s3引用，这样，s3指向了堆中创建的这个&rdquo;xyz&rdquo;字符串对象。s4则指向了堆中创建的另一个&rdquo;xyz&rdquo;字符串对象。s3 、s4是两个指向不同对象的引用，结果当然是false。
三、Intern的实现原理 /** * Returns a canonical representation for the string object. * &lt;p&gt; * A pool of strings, initially empty, is maintained privately by the * class {@code String}.
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://ly19911114.github.io/post/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
  
  <hr/>
  
  <article>
  <header>
    <h2><a href="https://ly19911114.github.io/post/%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9/">如何避免重复消费</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2020-03-03T22:40:40&#43;08:00">
          Mar 3, 2020
        </time>
      </div>
    </div>
  </header>
  <div>
    回答这个问题，首先你别听到重复消息这个事儿，就一无所知吧，你先大概说一说可能会有哪些重复消费的问题。
首先，比如 RabbitMQ、RocketMQ、Kafka，都有可能会出现消息重复消费的问题，正常。因为这问题通常不是 MQ 自己保证的，是由我们开发来保证的。挑一个 Kafka 来举个例子，说说怎么重复消费吧。
Kafka 实际上有个 offset 的概念，就是每个消息写进去，都有一个 offset，代表消息的序号，然后 consumer 消费了数据之后，每隔一段时间（定时定期），会把自己消费过的消息的 offset 提交一下，表示“我已经消费过了，下次我要是重启啥的，你就让我继续从上次消费到的 offset 来继续消费吧”。
但是凡事总有意外，比如我们之前生产经常遇到的，就是你有时候重启系统，看你怎么重启了，如果碰到点着急的，直接 kill 进程了，再重启。这会导致 consumer 有些消息处理了，但是没来得及提交 offset，尴尬了。重启之后，少数消息会再次消费一次。(右边的生产者为消费者)
image.png
举个栗子。
有这么个场景。数据 1/2/3 依次进入 kafka，kafka 会给这三条数据每条分配一个 offset，代表这条数据的序号，分配的 offset 依次是 152/153/154。消费者从 kafka 去消费的时候，也是按照这个顺序去消费。假如当消费者消费了 offset=153 的这条数据，刚准备去提交 offset 到 zookeeper，此时消费者进程被重启了。那么此时消费过的数据 1&frasl;2 的 offset 并没有提交，kafka 也就不知道你已经消费了 offset=153 这条数据。那么重启之后，消费者会找 kafka 说，嘿，哥儿们，你给我接着把上次我消费到的那个地方后面的数据继续给我传递过来。数据 1&frasl;2 再次被消费。
如果消费者干的事儿是拿一条数据就往数据库里写一条，会导致说，你可能就把数据 1&frasl;2 在数据库里插入了 2 次，那么数据就错啦。
其实重复消费不可怕，可怕的是你没考虑到重复消费之后，怎么保证幂等性。
举个例子吧。假设你有个系统，消费一条消息就往数据库里插入一条数据，要是你一个消息重复两次，你不就插入了两条，这数据不就错了？但是你要是消费到第二次的时候，自己判断一下是否已经消费过了，若是就直接扔了，这样不就保留了一条数据，从而保证了数据的正确性。
一条数据重复出现两次，数据库里就只有一条数据，这就保证了系统的幂等性。
幂等性，通俗点说，就一个数据，或者一个请求，给你重复来多次，你得确保对应的数据是不会改变的，不能出错。
所以第二个问题来了，怎么保证消息队列消费的幂等性？
其实还是得结合业务来思考，我这里给几个思路：
 比如你拿个数据要写库，你先根据主键查一下，如果这数据都有了，你就别插入了，update 一下好吧。 比如你是写 Redis，那没问题了，反正每次都是 set，天然幂等性。 比如你不是上面两个场景，那做的稍微复杂一点，你需要让生产者发送每条数据的时候，里面加一个全局唯一的 id，类似订单 id 之类的东西，然后你这里消费到了之后，先根据这个 id 去比如 Redis 里查一下，之前消费过吗？如果没有消费过，你就处理，然后这个 id 写 Redis。如果消费过了，那你就别处理了，保证别重复处理相同的消息即可。 比如基于数据库的唯一键来保证重复数据不会重复插入多条。因为有唯一键约束了，重复数据插入只会报错，不会导致数据库中出现脏数据。  image.
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://ly19911114.github.io/post/%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
</div>
<nav class="pagination" role="navigation">

  <hr />


  <span class="page-number">Page 1 of 3</span>

<a class="older-posts" href="/page/2/">Older Posts <span aria-hidden="true">&raquo;</span></a>

</nav>

  </main>
  <footer class="container global-footer">
    <div class="copyright-note pull-left">
      
    </div>
    <div class="sns-links hidden-print">
  
  
  
  
  
  
  
  
  
  
  
  
</div>

  </footer>

  <script src="https://ly19911114.github.io/js/highlight.pack.js"></script>
  <script>
    hljs.initHighlightingOnLoad();
  </script>
  
  
</body>
</html>


