<!DOCTYPE html>
<html lang="en-us">
<head prefix="og: http://ogp.me/ns#">
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />
  <meta property="og:title" content=" Welcome to the mysterious world" />
  
  <meta property="og:site_name" content="Welcome to the mysterious world" />
  <meta property="og:url" content="https://ly19911114.github.io/" />
  
  
  <meta property="og:type" content="website" />
  

  <title>
     Welcome to the mysterious world
  </title>

  <link rel="stylesheet" href="https://ly19911114.github.io/css/bootstrap.min.css" />
  <link rel="stylesheet" href="https://ly19911114.github.io/css/main.css" />
  <link rel="stylesheet" href="https://ly19911114.github.io/css/font-awesome.min.css" />
  <link rel="stylesheet" href="https://ly19911114.github.io/css/github.css" />
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400" type="text/css">
  <link rel="shortcut icon" href="https://ly19911114.github.io/images/favicon.ico" />
  <link rel="apple-touch-icon" href="https://ly19911114.github.io/images/apple-touch-icon.png" />
  
  <link href="https://ly19911114.github.io/index.xml" rel="alternate" type="application/rss+xml" title="Welcome to the mysterious world" />
  
</head>
<body>
    <header class="global-header"  style="background-image:url( /images/bg.jpg )">
    <section class="header-text">
      <h1><a href="https://ly19911114.github.io/">Welcome to the mysterious world</a></h1>
      
      <div class="sns-links hidden-print">
  
  
  
  
  
  
  
  
  
  
  
  
</div>

      
      
      <a href="https://ly19911114.github.io/index.xml" class="btn-header btn-subscribe hidden-xs">
        <i class="fa fa-rss" aria-hidden="true"></i>
        &nbsp;Subscribe
      </a>
      
    </section>
  </header>
  <main class="container">

<div class="article-list">
  
  
  <article>
  <header>
    <h2><a href="https://ly19911114.github.io/post/mybatis-%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E5%92%8C%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E7%9A%84%E5%8C%BA%E5%88%AB%E7%BB%83%E4%B9%A0/">一级缓存和二级缓存的区别练习</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2020-02-24T11:18:49&#43;08:00">
          Feb 24, 2020
        </time>
      </div>
    </div>
  </header>
  <div>
    Mybatis 为我们提供了一级缓存和二级缓存，可以通过下图来理解：
①、一级缓存是SqlSession级别的缓存。在操作数据库时需要构造sqlSession对象，在对象中有一个数据结构（HashMap）用于存储缓存数据。不同的sqlSession之间的缓存数据区域（HashMap）是互相不影响的。
②、二级缓存是mapper级别的缓存，多个SqlSession去操作同一个Mapper的sql语句，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。
1、一级缓存
①、我们在一个 sqlSession 中，对 User 表根据id进行两次查询，查看他们发出sql语句的情况。
@Test
public void testSelectOrderAndUserByOrderId(){
​ //根据 sqlSessionFactory 产生 session
​ SqlSession sqlSession = sessionFactory.openSession();
​ String statement = &ldquo;one.to.one.mapper.OrdersMapper.selectOrderAndUserByOrderID&rdquo;;
​ UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
​ //第一次查询，发出sql语句，并将查询的结果放入缓存中
​ User u1 = userMapper.selectUserByUserId(1);
​ System.out.println(u1);
​ //第二次查询，由于是同一个sqlSession,会在缓存中查找查询结果
​ //如果有，则直接从缓存中取出来，不和数据库进行交互
​ User u2 = userMapper.selectUserByUserId(1);
​ System.out.println(u2);
​ sqlSession.close();
}
查看控制台打印情况：
②、 同样是对user表进行两次查询，只不过两次查询之间进行了一次update操作。
@Test
public void testSelectOrderAndUserByOrderId(){
​ //根据 sqlSessionFactory 产生 session
​ SqlSession sqlSession = sessionFactory.
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://ly19911114.github.io/post/mybatis-%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E5%92%8C%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E7%9A%84%E5%8C%BA%E5%88%AB%E7%BB%83%E4%B9%A0/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
  
  <hr/>
  
  <article>
  <header>
    <h2><a href="https://ly19911114.github.io/post/linux%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85redis%E5%92%8C%E7%A2%B0%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/">Linux虚拟机安装Redis和碰到的问题</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2020-02-20T01:09:32&#43;08:00">
          Feb 20, 2020
        </time>
      </div>
    </div>
  </header>
  <div>
    1、解决could not retrieve mirrorlist，
 1.sudo 2.sudo su用sudo命令进入管理员账号 vim /etc/sysconfig/network-scripts/ifcfg-ens33 (不一定是ens33，要看清楚自己的文件名字)  　3.将ONBOOT改为yes，wq!保存退出
 4.重新启动网络 $ service network restart  ​
2、 安装wget yum install wget
​
3、 下载redis安装包
 wget http://download.redis.io/releases/redis-4.0.6.tar.gz  ​
4、 解压压缩包
 tar zxvf redis-4.0.6.tar.gz  ​
5、yum install gcc
​
6、跳转到redis解压目录下 cd redis-4.0.6
​
7、编译安装 make MALLOC=libc　 8、cd src &amp;&amp; make install 9、测试是否安装成功 ./redis-server  
  </div>
  
</article>

  
  
  <hr/>
  
  <article>
  <header>
    <h2><a href="https://ly19911114.github.io/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1springcloud%E5%92%8Cdocker%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AF%A6%E8%A7%A3/">微服务SpringCloud和Docker知识点详解</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2020-02-18T16:26:31&#43;08:00">
          Feb 18, 2020
        </time>
      </div>
    </div>
  </header>
  <div>
    =============================================
SpringCloud课程笔记.txt
第一章 课程介绍和学习路线 1、微服务架构SpringCloud课程介绍 简介：课程介绍和课程大纲讲解，讲课风格和重点内容理解技巧
2、技术选型和学后水平 简介：课程所需基础和技术选型讲解，学完课程可以到达怎样的程度，
1、IDEA JDK8 Maven SpringBoot基础 Linux 2、理解掌握并开发SpringCloud里面主流架构和组件的基础使用，还有部分源码原理的理解 3、掌握学习的技巧和解决问题的思路  第二章 架构演进和分布式系统基础知识 1、传统架构演进到分布式架构 简介：讲解单机应用和分布式应用架构演进基础知识 (画图)
 高可用 LVS+keepalive 1、单体应用： 开发速度慢 启动时间长 依赖庞大 等等 2、微服务 易开发、理解和维护 独立的部署和启动 等 不足： 分布式系统-》分布式事务问题 需要管理多个服务-》服务治理  2、微服务核心基础讲解 简介：讲解微服务核心知识 ：网关、服务发现注册、配置中心、链路追踪、负载均衡器、熔断 1、网关：路由转发 + 过滤器 /api/v1/pruduct/ 商品服务 /api/v1/order/ 订单服务 /api/v1/user/ 用户服务
 2、服务注册发现：调用和被调用方的信息维护 3、配置中心：管理配置，动态更新 application.properties 4、链路追踪：分析调用链路耗时 例子：下单-》查询商品服务获取商品价格-》查询用户信息-》保存数据库 5、负载均衡器：分发负载 6、熔断：保护自己和被调用方  3、常见的微服务框架 简介:讲解常用的微服务框架
 consumer: 调用方 provider: 被调用方 一个接口一般都会充当两个角色（不是同时充当） 1、dubbo: zookeeper + dubbo + springmvc/springboot 官方地址：http://dubbo.
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://ly19911114.github.io/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1springcloud%E5%92%8Cdocker%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AF%A6%E8%A7%A3/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
  
  <hr/>
  
  <article>
  <header>
    <h2><a href="https://ly19911114.github.io/post/shiro%E7%9A%84%E5%A4%8D%E7%9B%98/">Shiro的复盘</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2020-02-12T20:42:30&#43;08:00">
          Feb 12, 2020
        </time>
      </div>
    </div>
  </header>
  <div>
    一、前言 智慧微仓项目用Shiro添加权限认证，目前已按照业务需求，完成，现在进行总结复盘，主要以代码为主，详细的教程在之前的文章有写，请转到文章&rdquo;shiro权限与SpringBoot整合的知识点&rdquo;。
二、自定义Realm 配置这里不再赘述，注意包不要导错，自定义的Realm要继承Shiro的AuthorizingRealm；包括授权和登录验证
package com.jeehome.micro.warehouse.config; import com.jeehome.micro.warehouse.entity.PermissionEntity; import com.jeehome.micro.warehouse.entity.RoleEntity; import com.jeehome.micro.warehouse.entity.UserEntity; import com.jeehome.micro.warehouse.service.UserService; import org.apache.shiro.authc.AuthenticationException; import org.apache.shiro.authc.AuthenticationInfo; import org.apache.shiro.authc.AuthenticationToken; import org.apache.shiro.authc.SimpleAuthenticationInfo; import org.apache.shiro.authz.AuthorizationInfo; import org.apache.shiro.authz.SimpleAuthorizationInfo; import org.apache.shiro.realm.AuthorizingRealm; import org.apache.shiro.subject.PrincipalCollection; import org.springframework.beans.factory.annotation.Autowired; import java.util.ArrayList; import java.util.List; /** * 自定义realm */ public class CustomRealm extends AuthorizingRealm { @Autowired private UserService userService; /** * 进行权限校验的时候调用 * * @param principals * @return */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) { System.out.println(&quot;授权 doGetAuthorizationInfo&quot;); //获取用户名 String userName = (String) principals.
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://ly19911114.github.io/post/shiro%E7%9A%84%E5%A4%8D%E7%9B%98/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
  
  <hr/>
  
  <article>
  <header>
    <h2><a href="https://ly19911114.github.io/post/springboot%E4%B8%8Eshiro%E7%9A%84%E5%85%B7%E4%BD%93%E9%A1%B9%E7%9B%AE/">Springboot与shiro的具体项目</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2020-01-06T15:43:28&#43;08:00">
          Jan 6, 2020
        </time>
      </div>
    </div>
  </header>
  <div>
    
  </div>
  
</article>

  
  
  <hr/>
  
  <article>
  <header>
    <h2><a href="https://ly19911114.github.io/post/svn%E5%88%86%E6%94%AF%E5%88%9B%E5%BB%BA%E5%92%8C%E4%B8%BB%E5%B9%B2%E4%BB%A3%E7%A0%81%E7%9A%84%E5%90%88%E5%B9%B6%E9%97%AE%E9%A2%98/">SVN分支创建和主干代码的合并问题</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2019-12-30T16:34:24&#43;08:00">
          Dec 30, 2019
        </time>
      </div>
    </div>
  </header>
  <div>
    最近项目中涉及到了SVN的创建分支，以及分支和主干代码的合并。在此记录一下主要的东西（恩，感觉这位博主的截图好暖心，就忍不住转一下了）~
一、创建分支的意义： 在日常项目开发及版本迭代的过程中，经常会遇到这样的场景：当前版本提交QA测试之后，一方面需要在主干上开发下一版本的新需求；另一方面还需要在新的分支上解决QA提的Bug。项目上线之后，需要将分支上的改动合并到主干上。这就需要需要我们熟练掌握分支开发及合并。
二、创建新分支的步骤  创建测试项目并使其和SVN进行关联： 首先我们在Android Studio中新建一个测试项目SVNTestDemo，然后使其和SVN进行关联（从SVN更新下来的项目可忽略此步，不熟悉此步骤的朋友们请请转至 上一篇）。 提交本地新增或改变的文件：创建新分支前，最好先将本地修改的文件提交至 SVN。SVN 每一次提交操作时，都会有一个对应的 Revision。这里我们需要记住创建分支前最后一次提交修改文件时，该操作对应的 Revision（非常重要），以供后续合并分支时使用。 创建新分支：将项目切换至Project目录，选中项目后点击右键，依次选择Subversion-&gt;Branch or Tag 如下图所示： 之后会弹出如下弹框： 可根据需要选择拷贝源、新分支目录、修改分支项目文件名等。然后填写Comment，点击OK。分支创建成功后，在SVN仓库branches目录对应的文件下，右键选择 SVN Update 拉取分支代码。如下图所示： 双击打开 branches 文件夹，然后右键选择 SVN Update 拉取分支代码： 拉取成功后，branches文件目录下会出现一个新的文件夹new_branch。至此，新分支创建彻底完成。  三、对主干和分支进行相互合并： 为方便测试，我们首先分别对分支和主干的文件进行修改并提交（仅供测试使用，实际项目中只有主干和分支文件或代码不相同时才需要合并）。合并之前需要先更新一下代码，保证目标分支本地的代码是最新的，避免不必要的冲突。
1. 将分支的改动合并到主干： 在Android Studio中打开主干项目，切换至Project目录，选中项目并点击右键，依次选择Subversion-&gt; Integrate Directory 如下图所示： 之后会弹出如下弹框： 注意（此处有坑！！！）：从上图可以看出合并时，Revision默认选中的都是HEAD（即：最新版），此时若点击OK，主干新创建的类会被删除，主干和分支同时修改的类会被分支覆盖，主干中的文件及其内容将变成和分支一模一样；
显然大多时候这并不是我们想要的，我们需要保留主干的新增文件，同时合并分支的改动。这时主干（即：Source 1）的 Revision就不应该是最新版 HEAD，而是之前我们所说的 创建分支前最后一次提交修改时，该操作所对应的 Revision。
获取该Revision的方式：选中Source 1右侧的Revision为Specified，然后点击其右侧的 … 按钮，弹出如下弹框： 从图中我们可以看到之前的提交记录，我们选中Revision 4，然后点击 OK 即可。
通过上面方式，修改分支合并时的配置页如下： 点击OK，解决合并时的冲突。运行无异常后，提交合并后的文件至SVN即可。
2. 将主干的改动合并到分支： 首先在Android Studio中打开分支项目，从SVN更新代码，保证分支对应的本地代码是最新的。 从主干合并至分支时的其他过程与上述合并过程基本一致，只需将合并配置页的Source 1和Source 2对应的分支路径进行调换，Source 1（即：分支路径）对应的Revision选择创建该分支时，该操作所对应的Revision即可。 点击OK，解决合并时的冲突。运行无异常后，提交合并后的文件至SVN即可。
（注意，将分支合并到主干上后，svn show log日志上是没有日志记录的，只有再次点击提交主干代码后，才会有日志记录哈~）
  </div>
  
</article>

  
  
  <hr/>
  
  <article>
  <header>
    <h2><a href="https://ly19911114.github.io/post/list%E9%9B%86%E5%90%88%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%AF%B9%E8%B1%A1/">List集合去除重复对象</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2019-12-30T10:18:24&#43;08:00">
          Dec 30, 2019
        </time>
      </div>
    </div>
  </header>
  <div>
    引言
最近公司的中间件的中转后台中需要用到List集合去除重复对象这一技术点，下面，由浅入深的进行讲解开展。
再分析代码之前，先来了解下equal和hashcode，因为要去除List重复对象，需要在实体类中重写这两个方法，先来了解这两个方法，更有助于理解代码。
Now,Let is go(Let is 懒的缩写了，这不重要！！)
内容比较冗长，还请耐心看完。
一、项目中为何要重写equals和hashcode方法。 equals()方法在object类中定义如下：
public boolean equals(Object obj) { return (this == obj); }  很明显是对两个对象的地址值进行的比较（即比较引用是否相同）。但是我们知道，String 、Math、Integer、Double等这些封装类在使用equals()方法时，已经覆盖了object类的equals()方法。
hashcode()方法在object类中的定义如下：
public native int hashCode();  hashCode()方法给对象返回一个hash code值。这个方法被用于hash tables，例如HashMap。
它的性质是：
在一个Java应用的执行期间，如果一个对象提供给equals做比较的信息没有被修改的话，该对象多次调用hashCode()方法，该方法必须始终如一返回同一个integer。
如果两个对象根据equals(Object)方法是相等的，那么调用二者各自的hashCode()方法必须产生同一个integer结果。
并不要求根据equals(java.lang.Object)方法不相等的两个对象，调用二者各自的hashCode()方法必须产生不同的integer结果。然而，程序员应该意识到对于不同的对象产生不同的integer结果，有可能会提高hash table的性能。
大量的实践表明，由Object类定义的hashCode()方法对于不同的对象返回不同的integer。
hashCode()方法和equal()方法的作用其实一样，在Java里都是用来对比两个对象是否相等一致，那么equal()既然已经能实现对比的功能了，为什么还要hashCode()呢？
​ 因为重写的equal（）里一般比较的比较全面比较复杂，这样效率就比较低，而利用hashCode()进行对比，则只要生成一个hash值进行比较就可以了，效率很高，那么hashCode()既然效率这么高为什么还要equal()呢？
​ 因为hashCode()并不是完全可靠，有时候不同的对象他们生成的hashcode也会一样（生成hash值得公式可能存在的问题），所以hashCode()只能说是大部分时候可靠，并不是绝对可靠，所以我们可以得出：
​ 1.equal()相等的两个对象他们的hashCode()肯定相等，也就是用equal()对比是绝对可靠的。
​ 2.hashCode()相等的两个对象他们的equal()不一定相等，也就是hashCode()不是绝对可靠的。
​ 所有对于需要大量并且快速的对比的话如果都用equal()去做显然效率太低，所以解决方式是，每当需要对比的时候，首先用hashCode()去对比，如果hashCode()不一样，则表示这两个对象肯定不相等（也就是不必再用equal()去再对比了）,如果hashCode()相同，此时再对比他们的equal()，如果equal()也相同，则表示这两个对象是真的相同了，这样既能大大提高了效率也保证了对比的绝对正确性！
然而hashCode()和equal()一样都是基本类Object里的方法，而和equal()一样，Object里hashCode()里面只是返回当前对象的地址，如果是这样的话，那么我们相同的一个类，new两个对象，由于他们在内存里的地址不同，则他们的hashCode（）不同，所以这显然不是我们想要的，所以我们必须重写我们类的hashCode()方法，即一个类，在hashCode()里面返回唯一的一个hash值。
综上所述，在实际项目中，根据也无需求，必须要重写equals和hashcode方法。
二、如何进行List对象的去除操作 首先要在实体类中重写equals()和hashcode()方法，至于为什么要重新，请参考标题一，下面是项目中 RfidGoodsResponse实体类的实际代码：
public class RfidGoodsResponse { private String goodsName; private int goodsNum; private Integer goodsId; public Integer getGoodsId() { return goodsId; } public void setGoodsId(Integer goodsId) { this.
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://ly19911114.github.io/post/list%E9%9B%86%E5%90%88%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%AF%B9%E8%B1%A1/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
  
  <hr/>
  
  <article>
  <header>
    <h2><a href="https://ly19911114.github.io/post/springboot%E4%B8%AD%E7%9A%84configuration%E6%B3%A8%E8%A7%A3%E5%92%8Cbean%E6%B3%A8%E8%A7%A3/">SpringBoot中的@Configuration注解和@Bean注解</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2019-12-23T23:38:03&#43;08:00">
          Dec 23, 2019
        </time>
      </div>
    </div>
  </header>
  <div>
    @Configuration
1.@Configuration注解底层是含有@Component ，所以@Configuration 具有和 @Component 的作用。
2.@Configuration注解相当于spring的xml配置文件中标签，里面可以配置bean。
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--实例化一个Person对象--&gt; &lt;bean id=&quot;person&quot; class=&quot;com.sff.app.bean.Person&quot;/&gt; &lt;/beans&gt;  那么@Configuration注解就相当于我们的spring-bean.xml文件中的&hellip;&hellip;，它可以这样使用。
/** * 配置类等价于spring-bean.xml文件 */ @Configuration public class AppConfig { }  @Bean
1.@Bean注解相当于spring的xml配置文件标签，告诉容器注入一个bean。
2.@Bean注解的方法上如果没通过bean指定实例名，默认实例名与方法名相同。
3.@Bean注解默认为单例模式，可以通过@Scope(&ldquo;prototype&rdquo;)设置为多例。
/** * 配置类等价于spring-bean.xml文件 */ @Configuration public class AppConfig { /*给容器中注册一个bean,类型是方法返回值，id就是方法名称*/ @Bean public Person person() { return new Person(&quot;Kate&quot;, 12); } }  
  </div>
  
</article>

  
  
  <hr/>
  
  <article>
  <header>
    <h2><a href="https://ly19911114.github.io/post/shiro%E6%9D%83%E9%99%90%E4%B8%8Espringboot%E6%95%B4%E5%90%88%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/">Shiro权限与SpringBoot整合</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2019-12-23T22:50:45&#43;08:00">
          Dec 23, 2019
        </time>
      </div>
    </div>
  </header>
  <div>
    title: &ldquo;shiro权限框架与SpringBoot的整合&rdquo; date: 2019-12-22T16:28:13+08:00 draft: true
近期在学习shiro的权限框架，整理资料如下：包括基本概念，单元测试，SpringBoot整合shiro框架的实操，最后是上线项目的整合
第1章 Shiro权限实战课程介绍 第1集 Shiro权限实战课程介绍 简介：讲解为什么要学这门课，Shiro权限框架的课程大纲和学后水平
 公司新项目需要用到、要么就是需要接收别人的代码、个人技术栈的成长 Springboot2.x/SpringMVC + Maven + jdk8 + IDEA/Eclipse
 学后水平：掌握Shiro在公司中实际的使用，包括明白里面的核心原理
  第2集 权限控制和初学JavaWeb处理访问权限控制 简介：讲解什么是权限控制，初学JavaWeb时处理流程
 什么是权限控制：  忽略特别细的概念，比如权限能细分很多种，功能权限，数据权限，管理权限等 理解两个概念：用户和资源，让指定的用户，只能操作指定的资源（CRUD）  初学javaweb时怎么做
 Filter接口中有一个doFilter方法，自己编写好业务Filter，并配置对哪个web资源进行拦截后 如果访问的路径命中对应的Filter，则会执行doFilter()方法，然后判断是否有权限进行访问对应的资源 /api/user/info?id=1
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws Exception { HttpServletRequest httpRequest=(HttpServletRequest)request; HttpServletResponse httpResponse=(HttpServletResponse)response; HttpSession session=httpRequest.getSession(); if(session.getAttribute(&quot;username&quot;)!=null){ chain.doFilter(request, response); } else { httpResponse.sendRedirect(httpRequest.getContextPath()+&quot;/login.jsp&quot;); } }    第2章 大话权限框架核心知识ACL和RBAC 第1集 权限框架设计之ACL和RBAC讲解 简介：介绍什么是ACL和RBAC
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://ly19911114.github.io/post/shiro%E6%9D%83%E9%99%90%E4%B8%8Espringboot%E6%95%B4%E5%90%88%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
  
  <hr/>
  
  <article>
  <header>
    <h2><a href="https://ly19911114.github.io/post/springboot%E9%A1%B9%E7%9B%AE%E8%A7%84%E8%8C%83%E6%80%BB%E7%BB%93/">Springboot项目规范总结</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2019-12-22T16:28:13&#43;08:00">
          Dec 22, 2019
        </time>
      </div>
    </div>
  </header>
  <div>
    
  </div>
  
</article>

  
</div>
<nav class="pagination" role="navigation">

  <hr />


<a class="newer-posts" href="/"><span aria-hidden="true">&laquo;</span> Newer Posts</a>

  <span class="page-number">Page 2 of 2</span>

</nav>

  </main>
  <footer class="container global-footer">
    <div class="copyright-note pull-left">
      
    </div>
    <div class="sns-links hidden-print">
  
  
  
  
  
  
  
  
  
  
  
  
</div>

  </footer>

  <script src="https://ly19911114.github.io/js/highlight.pack.js"></script>
  <script>
    hljs.initHighlightingOnLoad();
  </script>
  
  
</body>
</html>


