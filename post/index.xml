<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Welcome to the mysterious world</title>
    <link>https://ly19911114.github.io/post/</link>
    <description>Recent content in Posts on Welcome to the mysterious world</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 15 Apr 2020 21:06:29 +0800</lastBuildDate>
    
	<atom:link href="https://ly19911114.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>虚拟机栈与本地方法栈</title>
      <link>https://ly19911114.github.io/post/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E4%B8%8E%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88/</link>
      <pubDate>Wed, 15 Apr 2020 21:06:29 +0800</pubDate>
      
      <guid>https://ly19911114.github.io/post/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E4%B8%8E%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88/</guid>
      <description>一、虚拟机栈（VM Stack） 1.1）什么是虚拟机栈 　虚拟机栈是用于描述java方法执行的内存模型。
　每个java方法在执行时，会创建一个“栈帧（stack frame）”，栈帧的结构分为“局部变量表、操作数栈、动态链接、方法出口”几个部分（具体的作用会在字节码执行引擎章节中讲到，这里只需要了解栈帧是一个方法执行时所需要数据的结构）。我们常说的“堆内存、栈内存”中的“栈内存”指的便是虚拟机栈，确切地说，指的是虚拟机栈的栈帧中的局部变量表，因为这里存放了一个方法的所有局部变量。
　方法调用时，创建栈帧，并压入虚拟机栈；方法执行完毕，栈帧出栈并被销毁，如下图所示： 1.2）虚拟机栈的特点 　虚拟机栈是线程隔离的，即每个线程都有自己独立的虚拟机栈。
1.3）虚拟机栈的StackOverflowError 　若单个线程请求的栈深度大于虚拟机允许的深度，则会抛出StackOverflowError（栈溢出错误）。
　JVM会为每个线程的虚拟机栈分配一定的内存大小（-Xss参数），因此虚拟机栈能够容纳的栈帧数量是有限的，若栈帧不断进栈而不出栈，最终会导致当前线程虚拟机栈的内存空间耗尽，典型如一个无结束条件的递归函数调用，代码见下：
/** * java栈溢出StackOverFlowError * JVM参数：-Xss128k * Created by chenjunyi on 2018/4/25. */ public class JavaVMStackSOF { private int stackLength = -1; //通过递归调用造成StackOverFlowError public void stackLeak() { stackLength++; stackLeak(); } public static void main(String[] args) { JavaVMStackSOF oom = new JavaVMStackSOF(); try { oom.stackLeak(); } catch (Throwable e) { System.out.println(&amp;quot;Stack length:&amp;quot; + oom.</description>
    </item>
    
    <item>
      <title>Lists</title>
      <link>https://ly19911114.github.io/post/lists.newarraylist/</link>
      <pubDate>Wed, 15 Apr 2020 11:10:02 +0800</pubDate>
      
      <guid>https://ly19911114.github.io/post/lists.newarraylist/</guid>
      <description>1、List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;Integer&amp;gt;();  2、List&amp;lt;Integer&amp;gt; list = Lists.newArrayList();  Lists.newArrayList() 其实和 new ArrayList() 几乎一模一样, 唯一它帮你做的(其实是javac帮你做的), 就是自动推导(不是&amp;rdquo;倒&amp;rdquo;)尖括号里的数据类型。Lists是一个工具类，同样的Maps也是一个工具类，同样也可以这么使用。
Map&amp;lt;String,Object&amp;gt; map = Maps.newHashMap();  </description>
    </item>
    
    <item>
      <title>关于分页查询</title>
      <link>https://ly19911114.github.io/post/%E5%85%B3%E4%BA%8E%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/</link>
      <pubDate>Mon, 13 Apr 2020 13:42:02 +0800</pubDate>
      
      <guid>https://ly19911114.github.io/post/%E5%85%B3%E4%BA%8E%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/</guid>
      <description>最近有在关注分页查询的性能问题，在网上看了下，说是PageHelper分页查询在处理大数据量的时候会出现性能问题，查询比较慢，我们公司规定尽量不要去使用pagehelper插件，现在就分页查询做如下总结：
一、基础查询类 /** * 基础查询类 * @author shenqifeng * @version $Id: BaseParam.java, v 0.1 2019年11月29日 上午11:15:37 shenqifeng Exp $ */ @Slf4j @Data public class BaseParam { /**页码*/ private Integer page; //下一页的记录数 private Integer pageStart; /**每页条数*/ private Integer pageSize; /** * 计算起始条数 * * @param page * @param pageSize * @return * @throws BizException */ public static Integer getPageStart(Integer page, Integer pageSize) throws BizException { Integer start = 0; if (null == page || null == pageSize) { log.</description>
    </item>
    
    <item>
      <title>@JsonSerialize与@JsonDeserialize使用</title>
      <link>https://ly19911114.github.io/post/jsonserialize%E4%B8%8Ejsondeserialize%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Mon, 13 Apr 2020 12:04:58 +0800</pubDate>
      
      <guid>https://ly19911114.github.io/post/jsonserialize%E4%B8%8Ejsondeserialize%E4%BD%BF%E7%94%A8/</guid>
      <description>一、利用这两个注解，@JsonDeserialize把字符串转换为Long型，@JsonSerialize把Long型转换成字符串。 JsonDeserialize用法: 1、请求接收的是一个json，并且由对象接收
2、对象属性的set方法编写注解（注意：如果有类注解@Data，@JsonDeserialize可以直接写到属性上面）
例子：
//在此类中加了@Data的写法，@JsonDeserialize不必写到set方法上 @JsonDeserialize(using = LongJsonDeserializer.class) @JsonSerialize(using = LongJsonSerializer.class) private Long creatorId;  3、自定义实现:
/** * 将接收的前端字符串类型转换成Long类型 * @author xuwentao * @version $Id: LongJsonDeserializer.java, v 0.1 2019年5月15日 上午11:22:37 xuwentao Exp $ */ public class LongJsonDeserializer extends JsonDeserializer&amp;lt;Long&amp;gt; { private static final Logger logger = LoggerFactory.getLogger(LongJsonDeserializer.class); // @Override // public Long deserialize(JsonParser p, DeserializationContext ctxt) throws IOException, JsonProcessingException { // return null; // } @Override public Long deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) throws IOException { String value = jsonParser.</description>
    </item>
    
    <item>
      <title>关于redis分布式锁</title>
      <link>https://ly19911114.github.io/post/%E5%85%B3%E4%BA%8Eredis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</link>
      <pubDate>Sat, 11 Apr 2020 17:42:10 +0800</pubDate>
      
      <guid>https://ly19911114.github.io/post/%E5%85%B3%E4%BA%8Eredis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</guid>
      <description></description>
    </item>
    
    <item>
      <title>解决IDEA源码没有注释</title>
      <link>https://ly19911114.github.io/post/%E8%A7%A3%E5%86%B3idea%E6%BA%90%E7%A0%81%E6%B2%A1%E6%9C%89%E6%B3%A8%E9%87%8A/</link>
      <pubDate>Fri, 10 Apr 2020 16:31:53 +0800</pubDate>
      
      <guid>https://ly19911114.github.io/post/%E8%A7%A3%E5%86%B3idea%E6%BA%90%E7%A0%81%E6%B2%A1%E6%9C%89%E6%B3%A8%E9%87%8A/</guid>
      <description>当你的源码没有注释，但又想阅读注解，Download Sources也无效的时候，试试我这招，百试百灵，千言万语汇成一句话：在IDEA工具界面的左下角，有个点击Terminal，输入命令：mvn dependency:resolve -Dclassifier=sources，然后再点击Download Sources，OK，大功告成！</description>
    </item>
    
    <item>
      <title>Mybatis中Like模糊查询</title>
      <link>https://ly19911114.github.io/post/mybatis%E4%B8%ADlike%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2/</link>
      <pubDate>Mon, 06 Apr 2020 22:06:48 +0800</pubDate>
      
      <guid>https://ly19911114.github.io/post/mybatis%E4%B8%ADlike%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2/</guid>
      <description>模糊查询在项目中还是经常使用的，本文就简单整理Mybatis中使用Like进行模糊查询的几种写法以及一些常见的问题。
使用Springboot简单配置一下Mybatis，然后进行说明。Springboot集成Mybatis这里就不做介绍了。
初始数据 方式一 在Mybatis中的第一种写法：
&amp;lt;!--有sql注入问题--&amp;gt; &amp;lt;select id=&amp;quot;findUserByLikeName1&amp;quot; parameterType=&amp;quot;java.lang.String&amp;quot; resultMap=&amp;quot;user&amp;quot;&amp;gt; select * from t_user where name like &#39;%${name}%&#39; &amp;lt;/select&amp;gt;  这种会有sql注入的问题，需要明白在 Mybatis中 $ 和 # 使用的区别。这种写法也不能加jdbcType=VARCHAR,否则也会报错。
做了个简单的测试：
@Test public void findUserByLikeName1(){ List&amp;lt;User&amp;gt; test = userMapper.findUserByLikeName1(&amp;quot;Cloud&amp;quot;); //select * from t_user where name like &#39;%Cloud%&#39; System.out.println(test.size());// 查出一条 List&amp;lt;User&amp;gt; test1 = userMapper.findUserByLikeName1(&amp;quot;&#39; or &#39;1=1&amp;quot;); //select * from t_user where name like &#39;%&#39; or &#39;1=1%&#39; // 分析： &#39;1=1%&#39; 成立 System.out.println(test1.size());// 查出了全部数据 }  注意：排序的字段也容易出现这个问题，在使用的时候也一定要注意。</description>
    </item>
    
    <item>
      <title>泛型详解</title>
      <link>https://ly19911114.github.io/post/%E6%B3%9B%E5%9E%8B%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sat, 04 Apr 2020 11:46:14 +0800</pubDate>
      
      <guid>https://ly19911114.github.io/post/%E6%B3%9B%E5%9E%8B%E8%AF%A6%E8%A7%A3/</guid>
      <description>对java的泛型特性的了解仅限于表面的浅浅一层，直到在学习设计模式时发现有不了解的用法，才想起详细的记录一下。 本文参考java 泛型详解、Java中的泛型方法、 java泛型详解  1. 概述 泛型在java中有很重要的地位，在面向对象编程及各种设计模式中有非常广泛的应用。
什么是泛型？为什么要使用泛型？

泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。 泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。  
2. 一个栗子 一个被举了无数次的例子：

List arrayList = new ArrayList(); arrayList.add(&amp;quot;aaaa&amp;quot;); arrayList.add(100); for(int i = 0; i&amp;lt; arrayList.size();i++){ String item = (String)arrayList.get(i); Log.d(&amp;quot;泛型测试&amp;quot;,&amp;quot;item = &amp;quot; + item); }  
毫无疑问，程序的运行结果会以崩溃结束：
java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String  ArrayList可以存放任意类型，例子中添加了一个String类型，添加了一个Integer类型，再使用时都以String的方式使用，因此程序崩溃了。为了解决类似这样的问题（在编译阶段就可以解决），泛型应运而生。
我们将第一行声明初始化list的代码更改一下，编译器会在编译阶段就能够帮我们发现类似这样的问题。
List&amp;lt;String&amp;gt; arrayList = new ArrayList&amp;lt;String&amp;gt;(); ... //arrayList.add(100); 在编译阶段，编译器就会报错  3. 特性 泛型只在编译阶段有效。看下面的代码：

List&amp;lt;String&amp;gt; stringArrayList = new ArrayList&amp;lt;String&amp;gt;(); List&amp;lt;Integer&amp;gt; integerArrayList = new ArrayList&amp;lt;Integer&amp;gt;(); Class classStringArrayList = stringArrayList.</description>
    </item>
    
    <item>
      <title>注解@Data的使用说明</title>
      <link>https://ly19911114.github.io/post/%E6%B3%A8%E8%A7%A3data%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</link>
      <pubDate>Wed, 01 Apr 2020 21:53:48 +0800</pubDate>
      
      <guid>https://ly19911114.github.io/post/%E6%B3%A8%E8%A7%A3data%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</guid>
      <description>@Data 注解的主要作用是提高代码的简洁，使用这个注解可以省去代码中大量的get()、 set()、 toString()等方法；
引入lombok 要使用 @Data 注解要先引入lombok，lombok 是什么，它是一个工具类库，可以用简单的注解形式来简化代码，提高开发效率。
 在maven中添加依赖
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.18.4&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt;  在编译器中添加插件 这里以IDEA为例，在setting的plugin里搜索lombok plugin，安装插件。
  使用 直接在相应的实体类上加上@Data注解即可；
比如一个简单的Person类，用常规的写法：
public class Person { private String name; private String address; private Integer age; private String hobbit; private String phone; public Person() { } public Person(String name, String address, Integer age, String hobbit, String phone) { this.name = name; this.address = address; this.age = age; this.</description>
    </item>
    
    <item>
      <title>关于设计模式</title>
      <link>https://ly19911114.github.io/post/%E5%85%B3%E4%BA%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 27 Mar 2020 00:01:55 +0800</pubDate>
      
      <guid>https://ly19911114.github.io/post/%E5%85%B3%E4%BA%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      <description>最近在读《Heade First设计模式》一书，收获颇多，代码放在GitHub仓库上，下载地址：https://github.com/ly19911114/design-mode.git</description>
    </item>
    
    <item>
      <title>Exist,in;not</title>
      <link>https://ly19911114.github.io/post/existinnot/</link>
      <pubDate>Sun, 22 Mar 2020 18:48:26 +0800</pubDate>
      
      <guid>https://ly19911114.github.io/post/existinnot/</guid>
      <description>in 是把外表和内表作hash join，而exists是对外表作loop，每次loop再对内表进行查询。一般大家都认为exists比in语句的效率要高，这种说法其实是不准确的，这个是要区分环境的。
exists对外表用loop逐条查询，每次查询都会查看exists的条件语句，当 exists里的条件语句能够返回记录行时(无论记录行是的多少，只要能返回)，条件就为真，返回当前loop到的这条记录，反之如果exists里的条件语句不能返回记录行，则当前loop到的这条记录被丢弃，exists的条件就像一个bool条件，当能返回结果集则为true，不能返回结果集则为 false。
例如：
select * from user where exists (select 1);
对user表的记录逐条取出，由于子条件中的select 1永远能返回记录行，那么user表的所有记录都将被加入结果集，所以与 select * from user;是一样的
又如下
select * from user where exists (select * from user where userId = 0);
可以知道对user表进行loop时，检查条件语句(select * from user where userId = 0),由于userId永远不为0，所以条件语句永远返回空集，条件永远为false，那么user表的所有记录都将被丢弃
not exists与exists相反，也就是当exists条件有结果集返回时，loop到的记录将被丢弃，否则将loop到的记录加入结果集
总的来说，如果A表有n条记录，那么exists查询就是将这n条记录逐条取出，然后判断n遍exists条件
in查询相当于多个or条件的叠加，这个比较好理解，比如下面的查询
select * from user where userId in (1, 2, 3);
等效于
select * from user where userId = 1 or userId = 2 or userId = 3;</description>
    </item>
    
    <item>
      <title>多线程执行AB任务的等待同步</title>
      <link>https://ly19911114.github.io/post/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8Cab%E4%BB%BB%E5%8A%A1%E7%9A%84%E7%AD%89%E5%BE%85%E5%90%8C%E6%AD%A5/</link>
      <pubDate>Wed, 18 Mar 2020 00:24:04 +0800</pubDate>
      
      <guid>https://ly19911114.github.io/post/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8Cab%E4%BB%BB%E5%8A%A1%E7%9A%84%E7%AD%89%E5%BE%85%E5%90%8C%E6%AD%A5/</guid>
      <description>内容描述： 在多线程中，有两个任务A与B，多线程执行任务A完成后再继续执行任务B，想到的两种方法一种线程间通信，使用条件变量方式，第二种就是使用CountDownLatch。
条件变量 主要使用的条件变量，判断是否任务Ａ已经做完，然后再执行任务Ｂ  public class Main { public static boolean[] flag = new boolean[3]; public static boolean judge(boolean[] f) { for (int i = 0; i &amp;lt; f.length; i++) { if (!f[i]) { return false; } } return true; } public static void main(String[] args) { for (int i = 0; i &amp;lt; flag.length; i++) { flag[i] = false; } new Thread(new Runnable() { public void run() { while (true) { if (!</description>
    </item>
    
    <item>
      <title>Java集合类线程安全问题以及解决办法</title>
      <link>https://ly19911114.github.io/post/java%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</link>
      <pubDate>Sat, 07 Mar 2020 15:08:23 +0800</pubDate>
      
      <guid>https://ly19911114.github.io/post/java%E9%9B%86%E5%90%88%E7%B1%BB%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</guid>
      <description>一、List 1.1 模拟多线程环境 ​ 多线程环境下，会抛出 java.util.ConcurrentModificationException 异常
public static void listNotSafe() { List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; 30; i++) { new Thread(() -&amp;gt; { list.add(UUID.randomUUID().toString().substring(0, 8)); System.out.println(list); }).start(); } }  1.2 异常原因  多线程环境下，并发争抢修改导致出现该异常。  1.3 解决办法 // 1. 使用线程安全类 Vector new Vector(); // 2. 使用 Collections 工具类封装 ArrayList Collections.synchronizedList(new ArrayList&amp;lt;&amp;gt;()); // 3. 使用 java.util.concurrent.CopyOnWriteArrayList; new CopyOnWriteArrayList&amp;lt;&amp;gt;();  1.4 写时复制思想 CopyOnWrite 容器即写时复制的容器。往一个容器添加元素的时候，不直接往当前容器Object[]添加，而是先将当前容器Object[]进行Copy, 复制出一个新的容器Object[] newElements， 然后新的容器Object[] newElements 里添加元素，添加完元素之后，再将原容器的引用指向新的容器 setArray(newElements); 这样做的好处是可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。  // CopyOnWriteArrayList.</description>
    </item>
    
    <item>
      <title>字符串常量池深入理解</title>
      <link>https://ly19911114.github.io/post/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/</link>
      <pubDate>Sat, 07 Mar 2020 13:36:23 +0800</pubDate>
      
      <guid>https://ly19911114.github.io/post/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/</guid>
      <description>一、概述 在分析字符串常量池之前，先来分析一下java的内存区域，然后再各种的情况分析一下各种情况下的情况；
在《深入理解java虚拟机》这本书上是这样写的：对于HotSpot虚拟机，根据官方发布的路线图信息，现在也有放弃永久代并逐步的改为采用Native Memory来实现方法区的规划了，在目前已经发布的JDK1.7的HotSpot中，已经把原来存放在方法区中的字符串常量池移出。根据查阅的资料显示在JDK1.7以后的版本中字符串常量池移到堆内存区域；同时在jdk1.8中移除整个永久代，取而代之的是一个叫元空间（Metaspace）的区域
在 JAVA 语言中有8中基本类型和一种比较特殊的类型String。这些类型为了使他们在运行过程中速度更快，更节省内存，都提供了一种常量池的概念。常量池就类似一个JAVA系统级别提供的缓存。
8种基本类型的常量池都是系统协调的，String类型的常量池比较特殊。它的主要使用方法有两种：
 直接使用双引号声明出来的String对象会直接存储在常量池中。 如果不是用双引号声明的String对象，可以使用String提供的intern方法。intern 方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中  二、Java中两种创建字符串对象的方法的分析
String s1 = &amp;quot;abc&amp;quot;; String s2 = &amp;quot;abc&amp;quot;; System.out.println(s1==s2);  结果是 true；
采用字面值的方式创建一个字符串时，JVM首先会去字符串池中查找是否存在&amp;rdquo;abc&amp;rdquo;这个对象，如果不存在，则在字符串常量池中创建&amp;rdquo;abc&amp;rdquo;这个对象，然后将池中&amp;rdquo;abc&amp;rdquo;这个对象的引用地址返回给&amp;rdquo;abc&amp;rdquo;对象的引用s1，这样s1会指向字符串常量池中&amp;rdquo;abc&amp;rdquo;这个字符串对象；如果存在，则不创建任何对象，直接将池中&amp;rdquo;abc&amp;rdquo;这个对象的地址返回，赋给引用s2。因为s1、s2都是指向同一个字符串池中的&amp;rdquo;abc&amp;rdquo;对象，所以结果为true。
String s3 = new String(&amp;quot;xyz&amp;quot;); String s4 = new String(&amp;quot;xyz&amp;quot;); System.out.println(s3==s4);  结果是 false
采用new关键字新建一个字符串对象时，JVM首先在字符串池中查找有没有&amp;rdquo;xyz&amp;rdquo;这个字符串对象，如果有，则不在池中再去创建&amp;rdquo;xyz&amp;rdquo;这个对象了，直接在堆中创建一个&amp;rdquo;xyz&amp;rdquo;字符串对象，然后将堆中的这个&amp;rdquo;xyz&amp;rdquo;对象的地址返回赋给引用s3，这样，s3就指向了堆中创建的这个&amp;rdquo;xyz&amp;rdquo;字符串对象；如果没有，则首先在字符串池中创建一个&amp;rdquo;xyz&amp;rdquo;字符串对象，然后再在堆中创建一个&amp;rdquo;xyz&amp;rdquo;字符串对象，然后将堆中这个&amp;rdquo;xyz&amp;rdquo;字符串对象的地址返回赋给s3引用，这样，s3指向了堆中创建的这个&amp;rdquo;xyz&amp;rdquo;字符串对象。s4则指向了堆中创建的另一个&amp;rdquo;xyz&amp;rdquo;字符串对象。s3 、s4是两个指向不同对象的引用，结果当然是false。
三、Intern的实现原理 /** * Returns a canonical representation for the string object. * &amp;lt;p&amp;gt; * A pool of strings, initially empty, is maintained privately by the * class {@code String}.</description>
    </item>
    
    <item>
      <title>如何避免重复消费</title>
      <link>https://ly19911114.github.io/post/%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9/</link>
      <pubDate>Tue, 03 Mar 2020 22:40:40 +0800</pubDate>
      
      <guid>https://ly19911114.github.io/post/%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9/</guid>
      <description>回答这个问题，首先你别听到重复消息这个事儿，就一无所知吧，你先大概说一说可能会有哪些重复消费的问题。
首先，比如 RabbitMQ、RocketMQ、Kafka，都有可能会出现消息重复消费的问题，正常。因为这问题通常不是 MQ 自己保证的，是由我们开发来保证的。挑一个 Kafka 来举个例子，说说怎么重复消费吧。
Kafka 实际上有个 offset 的概念，就是每个消息写进去，都有一个 offset，代表消息的序号，然后 consumer 消费了数据之后，每隔一段时间（定时定期），会把自己消费过的消息的 offset 提交一下，表示“我已经消费过了，下次我要是重启啥的，你就让我继续从上次消费到的 offset 来继续消费吧”。
但是凡事总有意外，比如我们之前生产经常遇到的，就是你有时候重启系统，看你怎么重启了，如果碰到点着急的，直接 kill 进程了，再重启。这会导致 consumer 有些消息处理了，但是没来得及提交 offset，尴尬了。重启之后，少数消息会再次消费一次。(右边的生产者为消费者)
image.png
举个栗子。
有这么个场景。数据 1/2/3 依次进入 kafka，kafka 会给这三条数据每条分配一个 offset，代表这条数据的序号，分配的 offset 依次是 152/153/154。消费者从 kafka 去消费的时候，也是按照这个顺序去消费。假如当消费者消费了 offset=153 的这条数据，刚准备去提交 offset 到 zookeeper，此时消费者进程被重启了。那么此时消费过的数据 1&amp;frasl;2 的 offset 并没有提交，kafka 也就不知道你已经消费了 offset=153 这条数据。那么重启之后，消费者会找 kafka 说，嘿，哥儿们，你给我接着把上次我消费到的那个地方后面的数据继续给我传递过来。数据 1&amp;frasl;2 再次被消费。
如果消费者干的事儿是拿一条数据就往数据库里写一条，会导致说，你可能就把数据 1&amp;frasl;2 在数据库里插入了 2 次，那么数据就错啦。
其实重复消费不可怕，可怕的是你没考虑到重复消费之后，怎么保证幂等性。
举个例子吧。假设你有个系统，消费一条消息就往数据库里插入一条数据，要是你一个消息重复两次，你不就插入了两条，这数据不就错了？但是你要是消费到第二次的时候，自己判断一下是否已经消费过了，若是就直接扔了，这样不就保留了一条数据，从而保证了数据的正确性。
一条数据重复出现两次，数据库里就只有一条数据，这就保证了系统的幂等性。
幂等性，通俗点说，就一个数据，或者一个请求，给你重复来多次，你得确保对应的数据是不会改变的，不能出错。
所以第二个问题来了，怎么保证消息队列消费的幂等性？
其实还是得结合业务来思考，我这里给几个思路：
 比如你拿个数据要写库，你先根据主键查一下，如果这数据都有了，你就别插入了，update 一下好吧。 比如你是写 Redis，那没问题了，反正每次都是 set，天然幂等性。 比如你不是上面两个场景，那做的稍微复杂一点，你需要让生产者发送每条数据的时候，里面加一个全局唯一的 id，类似订单 id 之类的东西，然后你这里消费到了之后，先根据这个 id 去比如 Redis 里查一下，之前消费过吗？如果没有消费过，你就处理，然后这个 id 写 Redis。如果消费过了，那你就别处理了，保证别重复处理相同的消息即可。 比如基于数据库的唯一键来保证重复数据不会重复插入多条。因为有唯一键约束了，重复数据插入只会报错，不会导致数据库中出现脏数据。  image.</description>
    </item>
    
    <item>
      <title>String,StringBuilder,StringBuffer</title>
      <link>https://ly19911114.github.io/post/stringstringbuilderstringbuffer/</link>
      <pubDate>Tue, 03 Mar 2020 21:16:26 +0800</pubDate>
      
      <guid>https://ly19911114.github.io/post/stringstringbuilderstringbuffer/</guid>
      <description>1.运行速度:StringBuilder &amp;gt;StringBuffer &amp;gt;String String为字符串常量，而StringBuilder和StringBuffer均为字符串变量，即String对象一旦创建之后该对象是不可更改的，但后两者的对象是变量，是可以更改的。Java中对String对象进行的操作实际上是一个不断创建新的对象并且将旧的对象回收的一个过程，所以执行速度很慢。而StringBuilder和StringBuffer的对象是变量，对变量进行操作就是直接对该对象进行更改，而不进行创建和回收的操作，所以速度要比String快很多。
2.线程安全:StringBuilder是线程不安全的，而StringBuffer是线程安全的 如果一个StringBuffer对象在字符串缓冲区被多个线程使用时，StringBuffer中很多方法可以带有synchronized关键字，所以可以保证线程是安全的，但StringBuilder的方法则没有该关键字，所以不能保证线程安全，有可能会出现一些错误的操作。所以如果要进行的操作是多线程的，那么就要使用StringBuffer，但是在单线程的情况下，还是建议使用速度比较快的StringBuilder。
3.使用场景 String：适用于少量的字符串操作的情况
StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况
StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况
String String类是不可变类，即一旦一个String对象被创建以后，包含在这个对象中的字符序列是不可改变的，直至这个对象被销毁。
 这个是String类的解释，之前小咸儿看到这个情况，不能理解上述的解释，如下
String a = &amp;quot;123&amp;quot;; a = &amp;quot;456&amp;quot;; *// 打印出来的a为456* System.out.println(a)   看到这里，小咸儿不明白了，这不是明明已经对他进行修改了吗？为什么还说他是一个不可变类呢？
 经过小咸儿和小伙伴们的学习，明白String类不可变在哪里体现出来的，接下来就看一张上述a对象的内存存储空间图
看到这里，小咸儿不明白了，这不是明明已经对他进行修改了吗？为什么还说他是一个不可变类呢？
 经过小咸儿和小伙伴们的学习，明白String类不可变在哪里体现出来的，接下来就看一张上述a对象的内存存储空间图 可以看出来，再次给a赋值时，并不是对原来堆中实例对象进行重新赋值，而是生成一个新的实例对象，并且指向“456”这个字符串，a则指向最新生成的实例对象，之前的实例对象仍然存在，如果没有被再次引用，则会被垃圾回收。
StringBuffer StringBuffer对象则代表一个字符序列可变的字符串，当一个StringBuffer被创建以后，通过StringBuffer提供的append()、insert()、reverse()、setCharAt()、setLength()等方法可以改变这个字符串对象的字符序列。一旦通过StringBuffer生成了最终想要的字符串，就可以调用它的toString()方法将其转换为一个String对象。
StringBuffer b = new StringBuffer(&amp;quot;123&amp;quot;); b.append(&amp;quot;456&amp;quot;); // b打印结果为：123456 System.out.println(b);  在看一下b对象的内存空间图： 所以说StringBuffer对象是一个字符序列可变的字符串，它没有重新生成一个对象，而且在原来的对象中可以连接新的字符串。
StringBuilder StringBuilder类也代表可变字符串对象。实际上，StringBuilder和StringBuffer基本相似，两个类的构造器和方法也基本相同。不同的是：StringBuffer是线程安全的，而StringBuilder则没有实现线程安全功能，所以性能略高。
StringBuffer是如何实现线程安全的呢？ StringBuffer类中实现的方法： StringBuilder类中实现的方法：
由此可见，StringBuffer类中的方法都添加了synchronized关键字，也就是给这个方法添加了一个锁，用来保证线程安全。
Java9的改进 Java9改进了字符串（包括String、StringBuffer、StringBuilder）的实现。在Java9以前字符串采用char[]数组来保存字符，因此字符串的每个字符占2字节；而Java9的字符串采用byte[]数组再加一个encoding-flag字段来保存字符，因此字符串的每个字符只占1字节。所以Java9的字符串更加节省空间，字符串的功能方法也没有受到影响。</description>
    </item>
    
    <item>
      <title>Hash底层实现原理</title>
      <link>https://ly19911114.github.io/post/hash%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</link>
      <pubDate>Tue, 03 Mar 2020 00:00:38 +0800</pubDate>
      
      <guid>https://ly19911114.github.io/post/hash%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</guid>
      <description>一、HashMap简介
\1. HashMap是用于存储Key-Value键值对的集合；
\2. HashMap根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，So具有很快的访问速度，但遍历顺序不确定；
\3. HashMap中键key为null的记录至多只允许一条，值value为null的记录可以有多条；
\4. HashMap非线程安全，即任一时刻允许多个线程同时写HashMap，可能会导致数据的不一致。
图1. HashMap的继承
*二、HashMap底层存储结构*
从整体结构上看HashMap是由数组+链表+红黑树（JDK1.8后增加了红黑树部分）实现的。
图2. HashMap整体存储结构
数组：
HashMap是一个用于存储Key-Value键值对的集合，每一个键值对也叫做一个Entry；这些Entry分散的存储在一个数组当中，该数组就是HashMap的主干。
图3. HashMap存储Entry的数组
链表：
因为数组Table的长度是有限的，使用hash函数计算时可能会出现index冲突的情况，所以我们需要链表来解决冲突；数组Table的每一个元素不单纯只是一个Entry对象，它还是一个链表的头节点，每一个Entry对象通过Next指针指向下一个Entry节点；当新来的Entry映射到冲突数组位置时，只需要插入对应的链表位置即可。
图4. HashMap链表
index冲突例子如下：
比如调用 hashMap.put(&amp;ldquo;China&amp;rdquo;, 0) ，插入一个Key为“China&amp;rdquo;的元素；这时候我们需要利用一个哈希函数来确定Entry的具体插入位置(index)：通过index = Hash(&amp;ldquo;China&amp;rdquo;)，假定最后计算出的index是2，那么Entry的插入结果如下：
图5. index冲突-1
但是，因为HashMap的长度是有限的，当插入的Entry越来越多时，再完美的Hash函数也难免会出现index冲突的情况。比如下面这样：
图6. index冲突-2
经过hash函数计算发现即将插入的Entry的index值也为2，这样就会与之前插入的Key为“China”的Entry起冲突；这时就可以用链表来解决冲突，当新来的Entry映射到冲突的数组位置时，只需要插入到对应的链表即可；此外，新来的Entry节点插入链表时使用的是“头插法”，即会插在链表的头部，因为HashMap的发明者认为后插入的Entry被查找的概率更大。
图7. index冲突-3
红黑树：
当链表长度超过阈值（8）时，会将链表转换为红黑树，使HashMap的性能得到进一步提升。
图8. HashMap红黑树
HashMap底层存储结构源码：
*Node类用来实现数组及链表的数据结构：*
1 /** 数组及链表的数据结构 2 * Basic hash bin node, used for most entries. (See below for 3 * TreeNode subclass, and in LinkedHashMap for its Entry subclass.</description>
    </item>
    
    <item>
      <title>SpringCloud的学习总结</title>
      <link>https://ly19911114.github.io/post/springcloud%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 01 Mar 2020 15:44:42 +0800</pubDate>
      
      <guid>https://ly19911114.github.io/post/springcloud%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</guid>
      <description>一、CAP的理论 CAP定理： 指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可同时获得。
 一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（所有节点在同一时间的数据完全一致，越多节点，数据同步越耗时）  ​
​ 可用性（A）：负载过大后，集群整体是否还能响应客户端的读写请求。（服务一直可用，而且是正常响应时间）
 分区容错性（P）：分区容忍性，就是高可用性，一个节点崩了，并不影响其它的节点（100个节点，挂了几个，不影响服务，越多机器越好） CAP理论就是说在分布式存储系统中，最多只能实现上面的两点。而由于当前的网络硬件肯定会出现延迟丢包等问题，所以分区容忍性是我们必须需要实现的。所以我们只能在一致性和可用性之间进行权衡  二、利用ribbiton在各个服务之间进行调用 例子：订单信息调用商品信息，代码如下
 首先在订单服务的启动类里面加入注解和ResTemplate
@Bean @LoadBalanced public RestTemplate restTemplate() { return new RestTemplate(); }  订单服务调用商品服务的接口，采用HTTP协议
  Map productMap = restTemplate.getForObject(&amp;ldquo;http://product-service/api/v1/product/find?id=&amp;quot;+productId, Map.class)&amp;mdash;》获取到商品服务的信息
package net.xdclass.order_service.service.impl; import net.xdclass.order_service.domain.ProductOrder; import net.xdclass.order_service.service.ProductOrderService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.cloud.client.ServiceInstance; import org.springframework.cloud.client.loadbalancer.LoadBalancerClient; import org.springframework.stereotype.Service; import org.springframework.web.client.RestTemplate; import sun.net.www.URLConnection; import sun.net.www.http.HttpClient; import java.util.Date; import java.util.Map; import java.util.UUID; @Service public class ProductOrderServiceImpl implements ProductOrderService { @Autowired private RestTemplate restTemplate; @Override public ProductOrder save(int userId, int productId) { Map&amp;lt;String,Object&amp;gt; productMap = restTemplate.</description>
    </item>
    
    <item>
      <title>一级缓存和二级缓存的区别练习</title>
      <link>https://ly19911114.github.io/post/mybatis-%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E5%92%8C%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E7%9A%84%E5%8C%BA%E5%88%AB%E7%BB%83%E4%B9%A0/</link>
      <pubDate>Mon, 24 Feb 2020 11:18:49 +0800</pubDate>
      
      <guid>https://ly19911114.github.io/post/mybatis-%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E5%92%8C%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E7%9A%84%E5%8C%BA%E5%88%AB%E7%BB%83%E4%B9%A0/</guid>
      <description>Mybatis 为我们提供了一级缓存和二级缓存，可以通过下图来理解：
①、一级缓存是SqlSession级别的缓存。在操作数据库时需要构造sqlSession对象，在对象中有一个数据结构（HashMap）用于存储缓存数据。不同的sqlSession之间的缓存数据区域（HashMap）是互相不影响的。
②、二级缓存是mapper级别的缓存，多个SqlSession去操作同一个Mapper的sql语句，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。
1、一级缓存
①、我们在一个 sqlSession 中，对 User 表根据id进行两次查询，查看他们发出sql语句的情况。
@Test
public void testSelectOrderAndUserByOrderId(){
​ //根据 sqlSessionFactory 产生 session
​ SqlSession sqlSession = sessionFactory.openSession();
​ String statement = &amp;ldquo;one.to.one.mapper.OrdersMapper.selectOrderAndUserByOrderID&amp;rdquo;;
​ UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
​ //第一次查询，发出sql语句，并将查询的结果放入缓存中
​ User u1 = userMapper.selectUserByUserId(1);
​ System.out.println(u1);
​ //第二次查询，由于是同一个sqlSession,会在缓存中查找查询结果
​ //如果有，则直接从缓存中取出来，不和数据库进行交互
​ User u2 = userMapper.selectUserByUserId(1);
​ System.out.println(u2);
​ sqlSession.close();
}
查看控制台打印情况：
②、 同样是对user表进行两次查询，只不过两次查询之间进行了一次update操作。
@Test
public void testSelectOrderAndUserByOrderId(){
​ //根据 sqlSessionFactory 产生 session
​ SqlSession sqlSession = sessionFactory.</description>
    </item>
    
    <item>
      <title>Linux虚拟机安装Redis和碰到的问题</title>
      <link>https://ly19911114.github.io/post/linux%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85redis%E5%92%8C%E7%A2%B0%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Thu, 20 Feb 2020 01:09:32 +0800</pubDate>
      
      <guid>https://ly19911114.github.io/post/linux%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85redis%E5%92%8C%E7%A2%B0%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>1、解决could not retrieve mirrorlist，
 1.sudo 2.sudo su用sudo命令进入管理员账号 vim /etc/sysconfig/network-scripts/ifcfg-ens33 (不一定是ens33，要看清楚自己的文件名字)  　3.将ONBOOT改为yes，wq!保存退出
 4.重新启动网络 $ service network restart  ​
2、 安装wget yum install wget
​
3、 下载redis安装包
 wget http://download.redis.io/releases/redis-4.0.6.tar.gz  ​
4、 解压压缩包
 tar zxvf redis-4.0.6.tar.gz  ​
5、yum install gcc
​
6、跳转到redis解压目录下 cd redis-4.0.6
​
7、编译安装 make MALLOC=libc　 8、cd src &amp;amp;&amp;amp; make install 9、测试是否安装成功 ./redis-server  </description>
    </item>
    
    <item>
      <title>微服务SpringCloud和Docker知识点详解</title>
      <link>https://ly19911114.github.io/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1springcloud%E5%92%8Cdocker%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Tue, 18 Feb 2020 16:26:31 +0800</pubDate>
      
      <guid>https://ly19911114.github.io/post/%E5%BE%AE%E6%9C%8D%E5%8A%A1springcloud%E5%92%8Cdocker%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AF%A6%E8%A7%A3/</guid>
      <description>=============================================
SpringCloud课程笔记.txt
第一章 课程介绍和学习路线 1、微服务架构SpringCloud课程介绍 简介：课程介绍和课程大纲讲解，讲课风格和重点内容理解技巧
2、技术选型和学后水平 简介：课程所需基础和技术选型讲解，学完课程可以到达怎样的程度，
1、IDEA JDK8 Maven SpringBoot基础 Linux 2、理解掌握并开发SpringCloud里面主流架构和组件的基础使用，还有部分源码原理的理解 3、掌握学习的技巧和解决问题的思路  第二章 架构演进和分布式系统基础知识 1、传统架构演进到分布式架构 简介：讲解单机应用和分布式应用架构演进基础知识 (画图)
 高可用 LVS+keepalive 1、单体应用： 开发速度慢 启动时间长 依赖庞大 等等 2、微服务 易开发、理解和维护 独立的部署和启动 等 不足： 分布式系统-》分布式事务问题 需要管理多个服务-》服务治理  2、微服务核心基础讲解 简介：讲解微服务核心知识 ：网关、服务发现注册、配置中心、链路追踪、负载均衡器、熔断 1、网关：路由转发 + 过滤器 /api/v1/pruduct/ 商品服务 /api/v1/order/ 订单服务 /api/v1/user/ 用户服务
 2、服务注册发现：调用和被调用方的信息维护 3、配置中心：管理配置，动态更新 application.properties 4、链路追踪：分析调用链路耗时 例子：下单-》查询商品服务获取商品价格-》查询用户信息-》保存数据库 5、负载均衡器：分发负载 6、熔断：保护自己和被调用方  3、常见的微服务框架 简介:讲解常用的微服务框架
 consumer: 调用方 provider: 被调用方 一个接口一般都会充当两个角色（不是同时充当） 1、dubbo: zookeeper + dubbo + springmvc/springboot 官方地址：http://dubbo.</description>
    </item>
    
    <item>
      <title>Shiro的复盘</title>
      <link>https://ly19911114.github.io/post/shiro%E7%9A%84%E5%A4%8D%E7%9B%98/</link>
      <pubDate>Wed, 12 Feb 2020 20:42:30 +0800</pubDate>
      
      <guid>https://ly19911114.github.io/post/shiro%E7%9A%84%E5%A4%8D%E7%9B%98/</guid>
      <description>一、前言 智慧微仓项目用Shiro添加权限认证，目前已按照业务需求，完成，现在进行总结复盘，主要以代码为主，详细的教程在之前的文章有写，请转到文章&amp;rdquo;shiro权限与SpringBoot整合的知识点&amp;rdquo;。
二、自定义Realm 配置这里不再赘述，注意包不要导错，自定义的Realm要继承Shiro的AuthorizingRealm；包括授权和登录验证
package com.jeehome.micro.warehouse.config; import com.jeehome.micro.warehouse.entity.PermissionEntity; import com.jeehome.micro.warehouse.entity.RoleEntity; import com.jeehome.micro.warehouse.entity.UserEntity; import com.jeehome.micro.warehouse.service.UserService; import org.apache.shiro.authc.AuthenticationException; import org.apache.shiro.authc.AuthenticationInfo; import org.apache.shiro.authc.AuthenticationToken; import org.apache.shiro.authc.SimpleAuthenticationInfo; import org.apache.shiro.authz.AuthorizationInfo; import org.apache.shiro.authz.SimpleAuthorizationInfo; import org.apache.shiro.realm.AuthorizingRealm; import org.apache.shiro.subject.PrincipalCollection; import org.springframework.beans.factory.annotation.Autowired; import java.util.ArrayList; import java.util.List; /** * 自定义realm */ public class CustomRealm extends AuthorizingRealm { @Autowired private UserService userService; /** * 进行权限校验的时候调用 * * @param principals * @return */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) { System.out.println(&amp;quot;授权 doGetAuthorizationInfo&amp;quot;); //获取用户名 String userName = (String) principals.</description>
    </item>
    
    <item>
      <title>Springboot与shiro的具体项目</title>
      <link>https://ly19911114.github.io/post/springboot%E4%B8%8Eshiro%E7%9A%84%E5%85%B7%E4%BD%93%E9%A1%B9%E7%9B%AE/</link>
      <pubDate>Mon, 06 Jan 2020 15:43:28 +0800</pubDate>
      
      <guid>https://ly19911114.github.io/post/springboot%E4%B8%8Eshiro%E7%9A%84%E5%85%B7%E4%BD%93%E9%A1%B9%E7%9B%AE/</guid>
      <description></description>
    </item>
    
    <item>
      <title>SVN分支创建和主干代码的合并问题</title>
      <link>https://ly19911114.github.io/post/svn%E5%88%86%E6%94%AF%E5%88%9B%E5%BB%BA%E5%92%8C%E4%B8%BB%E5%B9%B2%E4%BB%A3%E7%A0%81%E7%9A%84%E5%90%88%E5%B9%B6%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 30 Dec 2019 16:34:24 +0800</pubDate>
      
      <guid>https://ly19911114.github.io/post/svn%E5%88%86%E6%94%AF%E5%88%9B%E5%BB%BA%E5%92%8C%E4%B8%BB%E5%B9%B2%E4%BB%A3%E7%A0%81%E7%9A%84%E5%90%88%E5%B9%B6%E9%97%AE%E9%A2%98/</guid>
      <description>最近项目中涉及到了SVN的创建分支，以及分支和主干代码的合并。在此记录一下主要的东西（恩，感觉这位博主的截图好暖心，就忍不住转一下了）~
一、创建分支的意义： 在日常项目开发及版本迭代的过程中，经常会遇到这样的场景：当前版本提交QA测试之后，一方面需要在主干上开发下一版本的新需求；另一方面还需要在新的分支上解决QA提的Bug。项目上线之后，需要将分支上的改动合并到主干上。这就需要需要我们熟练掌握分支开发及合并。
二、创建新分支的步骤  创建测试项目并使其和SVN进行关联： 首先我们在Android Studio中新建一个测试项目SVNTestDemo，然后使其和SVN进行关联（从SVN更新下来的项目可忽略此步，不熟悉此步骤的朋友们请请转至 上一篇）。 提交本地新增或改变的文件：创建新分支前，最好先将本地修改的文件提交至 SVN。SVN 每一次提交操作时，都会有一个对应的 Revision。这里我们需要记住创建分支前最后一次提交修改文件时，该操作对应的 Revision（非常重要），以供后续合并分支时使用。 创建新分支：将项目切换至Project目录，选中项目后点击右键，依次选择Subversion-&amp;gt;Branch or Tag 如下图所示： 之后会弹出如下弹框： 可根据需要选择拷贝源、新分支目录、修改分支项目文件名等。然后填写Comment，点击OK。分支创建成功后，在SVN仓库branches目录对应的文件下，右键选择 SVN Update 拉取分支代码。如下图所示： 双击打开 branches 文件夹，然后右键选择 SVN Update 拉取分支代码： 拉取成功后，branches文件目录下会出现一个新的文件夹new_branch。至此，新分支创建彻底完成。  三、对主干和分支进行相互合并： 为方便测试，我们首先分别对分支和主干的文件进行修改并提交（仅供测试使用，实际项目中只有主干和分支文件或代码不相同时才需要合并）。合并之前需要先更新一下代码，保证目标分支本地的代码是最新的，避免不必要的冲突。
1. 将分支的改动合并到主干： 在Android Studio中打开主干项目，切换至Project目录，选中项目并点击右键，依次选择Subversion-&amp;gt; Integrate Directory 如下图所示： 之后会弹出如下弹框： 注意（此处有坑！！！）：从上图可以看出合并时，Revision默认选中的都是HEAD（即：最新版），此时若点击OK，主干新创建的类会被删除，主干和分支同时修改的类会被分支覆盖，主干中的文件及其内容将变成和分支一模一样；
显然大多时候这并不是我们想要的，我们需要保留主干的新增文件，同时合并分支的改动。这时主干（即：Source 1）的 Revision就不应该是最新版 HEAD，而是之前我们所说的 创建分支前最后一次提交修改时，该操作所对应的 Revision。
获取该Revision的方式：选中Source 1右侧的Revision为Specified，然后点击其右侧的 … 按钮，弹出如下弹框： 从图中我们可以看到之前的提交记录，我们选中Revision 4，然后点击 OK 即可。
通过上面方式，修改分支合并时的配置页如下： 点击OK，解决合并时的冲突。运行无异常后，提交合并后的文件至SVN即可。
2. 将主干的改动合并到分支： 首先在Android Studio中打开分支项目，从SVN更新代码，保证分支对应的本地代码是最新的。 从主干合并至分支时的其他过程与上述合并过程基本一致，只需将合并配置页的Source 1和Source 2对应的分支路径进行调换，Source 1（即：分支路径）对应的Revision选择创建该分支时，该操作所对应的Revision即可。 点击OK，解决合并时的冲突。运行无异常后，提交合并后的文件至SVN即可。
（注意，将分支合并到主干上后，svn show log日志上是没有日志记录的，只有再次点击提交主干代码后，才会有日志记录哈~）</description>
    </item>
    
    <item>
      <title>List集合去除重复对象</title>
      <link>https://ly19911114.github.io/post/list%E9%9B%86%E5%90%88%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Mon, 30 Dec 2019 10:18:24 +0800</pubDate>
      
      <guid>https://ly19911114.github.io/post/list%E9%9B%86%E5%90%88%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%AF%B9%E8%B1%A1/</guid>
      <description>引言
最近公司的中间件的中转后台中需要用到List集合去除重复对象这一技术点，下面，由浅入深的进行讲解开展。
再分析代码之前，先来了解下equal和hashcode，因为要去除List重复对象，需要在实体类中重写这两个方法，先来了解这两个方法，更有助于理解代码。
Now,Let is go(Let is 懒的缩写了，这不重要！！)
内容比较冗长，还请耐心看完。
一、项目中为何要重写equals和hashcode方法。 equals()方法在object类中定义如下：
public boolean equals(Object obj) { return (this == obj); }  很明显是对两个对象的地址值进行的比较（即比较引用是否相同）。但是我们知道，String 、Math、Integer、Double等这些封装类在使用equals()方法时，已经覆盖了object类的equals()方法。
hashcode()方法在object类中的定义如下：
public native int hashCode();  hashCode()方法给对象返回一个hash code值。这个方法被用于hash tables，例如HashMap。
它的性质是：
在一个Java应用的执行期间，如果一个对象提供给equals做比较的信息没有被修改的话，该对象多次调用hashCode()方法，该方法必须始终如一返回同一个integer。
如果两个对象根据equals(Object)方法是相等的，那么调用二者各自的hashCode()方法必须产生同一个integer结果。
并不要求根据equals(java.lang.Object)方法不相等的两个对象，调用二者各自的hashCode()方法必须产生不同的integer结果。然而，程序员应该意识到对于不同的对象产生不同的integer结果，有可能会提高hash table的性能。
大量的实践表明，由Object类定义的hashCode()方法对于不同的对象返回不同的integer。
hashCode()方法和equal()方法的作用其实一样，在Java里都是用来对比两个对象是否相等一致，那么equal()既然已经能实现对比的功能了，为什么还要hashCode()呢？
​ 因为重写的equal（）里一般比较的比较全面比较复杂，这样效率就比较低，而利用hashCode()进行对比，则只要生成一个hash值进行比较就可以了，效率很高，那么hashCode()既然效率这么高为什么还要equal()呢？
​ 因为hashCode()并不是完全可靠，有时候不同的对象他们生成的hashcode也会一样（生成hash值得公式可能存在的问题），所以hashCode()只能说是大部分时候可靠，并不是绝对可靠，所以我们可以得出：
​ 1.equal()相等的两个对象他们的hashCode()肯定相等，也就是用equal()对比是绝对可靠的。
​ 2.hashCode()相等的两个对象他们的equal()不一定相等，也就是hashCode()不是绝对可靠的。
​ 所有对于需要大量并且快速的对比的话如果都用equal()去做显然效率太低，所以解决方式是，每当需要对比的时候，首先用hashCode()去对比，如果hashCode()不一样，则表示这两个对象肯定不相等（也就是不必再用equal()去再对比了）,如果hashCode()相同，此时再对比他们的equal()，如果equal()也相同，则表示这两个对象是真的相同了，这样既能大大提高了效率也保证了对比的绝对正确性！
然而hashCode()和equal()一样都是基本类Object里的方法，而和equal()一样，Object里hashCode()里面只是返回当前对象的地址，如果是这样的话，那么我们相同的一个类，new两个对象，由于他们在内存里的地址不同，则他们的hashCode（）不同，所以这显然不是我们想要的，所以我们必须重写我们类的hashCode()方法，即一个类，在hashCode()里面返回唯一的一个hash值。
综上所述，在实际项目中，根据也无需求，必须要重写equals和hashcode方法。
二、如何进行List对象的去除操作 首先要在实体类中重写equals()和hashcode()方法，至于为什么要重新，请参考标题一，下面是项目中 RfidGoodsResponse实体类的实际代码：
public class RfidGoodsResponse { private String goodsName; private int goodsNum; private Integer goodsId; public Integer getGoodsId() { return goodsId; } public void setGoodsId(Integer goodsId) { this.</description>
    </item>
    
    <item>
      <title>SpringBoot中的@Configuration注解和@Bean注解</title>
      <link>https://ly19911114.github.io/post/springboot%E4%B8%AD%E7%9A%84configuration%E6%B3%A8%E8%A7%A3%E5%92%8Cbean%E6%B3%A8%E8%A7%A3/</link>
      <pubDate>Mon, 23 Dec 2019 23:38:03 +0800</pubDate>
      
      <guid>https://ly19911114.github.io/post/springboot%E4%B8%AD%E7%9A%84configuration%E6%B3%A8%E8%A7%A3%E5%92%8Cbean%E6%B3%A8%E8%A7%A3/</guid>
      <description>@Configuration
1.@Configuration注解底层是含有@Component ，所以@Configuration 具有和 @Component 的作用。
2.@Configuration注解相当于spring的xml配置文件中标签，里面可以配置bean。
&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt; &amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot; xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&amp;quot;&amp;gt; &amp;lt;!--实例化一个Person对象--&amp;gt; &amp;lt;bean id=&amp;quot;person&amp;quot; class=&amp;quot;com.sff.app.bean.Person&amp;quot;/&amp;gt; &amp;lt;/beans&amp;gt;  那么@Configuration注解就相当于我们的spring-bean.xml文件中的&amp;hellip;&amp;hellip;，它可以这样使用。
/** * 配置类等价于spring-bean.xml文件 */ @Configuration public class AppConfig { }  @Bean
1.@Bean注解相当于spring的xml配置文件标签，告诉容器注入一个bean。
2.@Bean注解的方法上如果没通过bean指定实例名，默认实例名与方法名相同。
3.@Bean注解默认为单例模式，可以通过@Scope(&amp;ldquo;prototype&amp;rdquo;)设置为多例。
/** * 配置类等价于spring-bean.xml文件 */ @Configuration public class AppConfig { /*给容器中注册一个bean,类型是方法返回值，id就是方法名称*/ @Bean public Person person() { return new Person(&amp;quot;Kate&amp;quot;, 12); } }  </description>
    </item>
    
    <item>
      <title>Shiro权限与SpringBoot整合</title>
      <link>https://ly19911114.github.io/post/shiro%E6%9D%83%E9%99%90%E4%B8%8Espringboot%E6%95%B4%E5%90%88%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/</link>
      <pubDate>Mon, 23 Dec 2019 22:50:45 +0800</pubDate>
      
      <guid>https://ly19911114.github.io/post/shiro%E6%9D%83%E9%99%90%E4%B8%8Espringboot%E6%95%B4%E5%90%88%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/</guid>
      <description>title: &amp;ldquo;shiro权限框架与SpringBoot的整合&amp;rdquo; date: 2019-12-22T16:28:13+08:00 draft: true
近期在学习shiro的权限框架，整理资料如下：包括基本概念，单元测试，SpringBoot整合shiro框架的实操，最后是上线项目的整合
第1章 Shiro权限实战课程介绍 第1集 Shiro权限实战课程介绍 简介：讲解为什么要学这门课，Shiro权限框架的课程大纲和学后水平
 公司新项目需要用到、要么就是需要接收别人的代码、个人技术栈的成长 Springboot2.x/SpringMVC + Maven + jdk8 + IDEA/Eclipse
 学后水平：掌握Shiro在公司中实际的使用，包括明白里面的核心原理
  第2集 权限控制和初学JavaWeb处理访问权限控制 简介：讲解什么是权限控制，初学JavaWeb时处理流程
 什么是权限控制：  忽略特别细的概念，比如权限能细分很多种，功能权限，数据权限，管理权限等 理解两个概念：用户和资源，让指定的用户，只能操作指定的资源（CRUD）  初学javaweb时怎么做
 Filter接口中有一个doFilter方法，自己编写好业务Filter，并配置对哪个web资源进行拦截后 如果访问的路径命中对应的Filter，则会执行doFilter()方法，然后判断是否有权限进行访问对应的资源 /api/user/info?id=1
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws Exception { HttpServletRequest httpRequest=(HttpServletRequest)request; HttpServletResponse httpResponse=(HttpServletResponse)response; HttpSession session=httpRequest.getSession(); if(session.getAttribute(&amp;quot;username&amp;quot;)!=null){ chain.doFilter(request, response); } else { httpResponse.sendRedirect(httpRequest.getContextPath()+&amp;quot;/login.jsp&amp;quot;); } }    第2章 大话权限框架核心知识ACL和RBAC 第1集 权限框架设计之ACL和RBAC讲解 简介：介绍什么是ACL和RBAC</description>
    </item>
    
    <item>
      <title>Springboot项目规范总结</title>
      <link>https://ly19911114.github.io/post/springboot%E9%A1%B9%E7%9B%AE%E8%A7%84%E8%8C%83%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 22 Dec 2019 16:28:13 +0800</pubDate>
      
      <guid>https://ly19911114.github.io/post/springboot%E9%A1%B9%E7%9B%AE%E8%A7%84%E8%8C%83%E6%80%BB%E7%BB%93/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>