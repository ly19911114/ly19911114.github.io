<!DOCTYPE html>
<html lang="en-us">
<head prefix="og: http://ogp.me/ns#">
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />
  <meta property="og:title" content=" Welcome to the mysterious world" />
  
  <meta property="og:site_name" content="Welcome to the mysterious world" />
  <meta property="og:url" content="https://ly19911114.github.io/" />
  
  
  <meta property="og:type" content="website" />
  

  <title>
     Welcome to the mysterious world
  </title>

  <link rel="stylesheet" href="https://ly19911114.github.io/css/bootstrap.min.css" />
  <link rel="stylesheet" href="https://ly19911114.github.io/css/main.css" />
  <link rel="stylesheet" href="https://ly19911114.github.io/css/font-awesome.min.css" />
  <link rel="stylesheet" href="https://ly19911114.github.io/css/github.css" />
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400" type="text/css">
  <link rel="shortcut icon" href="https://ly19911114.github.io/images/favicon.ico" />
  <link rel="apple-touch-icon" href="https://ly19911114.github.io/images/apple-touch-icon.png" />
  
  <link href="https://ly19911114.github.io/index.xml" rel="alternate" type="application/rss+xml" title="Welcome to the mysterious world" />
  
</head>
<body>
    <header class="global-header"  style="background-image:url( /images/bg.jpg )">
    <section class="header-text">
      <h1><a href="https://ly19911114.github.io/">Welcome to the mysterious world</a></h1>
      
      <div class="sns-links hidden-print">
  
  
  
  
  
  
  
  
  
  
  
  
</div>

      
      
      <a href="https://ly19911114.github.io/index.xml" class="btn-header btn-subscribe hidden-xs">
        <i class="fa fa-rss" aria-hidden="true"></i>
        &nbsp;Subscribe
      </a>
      
    </section>
  </header>
  <main class="container">

<div class="article-list">
  
  
  <article>
  <header>
    <h2><a href="https://ly19911114.github.io/post/lists.newarraylist/">Lists</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2020-04-15T11:10:02&#43;08:00">
          Apr 15, 2020
        </time>
      </div>
    </div>
  </header>
  <div>
    1、List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();  2、List&lt;Integer&gt; list = Lists.newArrayList();  Lists.newArrayList() 其实和 new ArrayList() 几乎一模一样, 唯一它帮你做的(其实是javac帮你做的), 就是自动推导(不是&rdquo;倒&rdquo;)尖括号里的数据类型。Lists是一个工具类，同样的Maps也是一个工具类，同样也可以这么使用。
Map&lt;String,Object&gt; map = Maps.newHashMap();  
  </div>
  
</article>

  
  
  <hr/>
  
  <article>
  <header>
    <h2><a href="https://ly19911114.github.io/post/%E5%85%B3%E4%BA%8E%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/">关于分页查询</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2020-04-13T13:42:02&#43;08:00">
          Apr 13, 2020
        </time>
      </div>
    </div>
  </header>
  <div>
    最近有在关注分页查询的性能问题，在网上看了下，说是PageHelper分页查询在处理大数据量的时候会出现性能问题，查询比较慢，我们公司规定尽量不要去使用pagehelper插件，现在就分页查询做如下总结：
一、基础查询类 /** * 基础查询类 * @author shenqifeng * @version $Id: BaseParam.java, v 0.1 2019年11月29日 上午11:15:37 shenqifeng Exp $ */ @Slf4j @Data public class BaseParam { /**页码*/ private Integer page; //下一页的记录数 private Integer pageStart; /**每页条数*/ private Integer pageSize; /** * 计算起始条数 * * @param page * @param pageSize * @return * @throws BizException */ public static Integer getPageStart(Integer page, Integer pageSize) throws BizException { Integer start = 0; if (null == page || null == pageSize) { log.
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://ly19911114.github.io/post/%E5%85%B3%E4%BA%8E%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
  
  <hr/>
  
  <article>
  <header>
    <h2><a href="https://ly19911114.github.io/post/jsonserialize%E4%B8%8Ejsondeserialize%E4%BD%BF%E7%94%A8/">@JsonSerialize与@JsonDeserialize使用</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2020-04-13T12:04:58&#43;08:00">
          Apr 13, 2020
        </time>
      </div>
    </div>
  </header>
  <div>
    一、利用这两个注解，@JsonDeserialize把字符串转换为Long型，@JsonSerialize把Long型转换成字符串。 JsonDeserialize用法: 1、请求接收的是一个json，并且由对象接收
2、对象属性的set方法编写注解（注意：如果有类注解@Data，@JsonDeserialize可以直接写到属性上面）
例子：
//在此类中加了@Data的写法，@JsonDeserialize不必写到set方法上 @JsonDeserialize(using = LongJsonDeserializer.class) @JsonSerialize(using = LongJsonSerializer.class) private Long creatorId;  3、自定义实现:
/** * 将接收的前端字符串类型转换成Long类型 * @author xuwentao * @version $Id: LongJsonDeserializer.java, v 0.1 2019年5月15日 上午11:22:37 xuwentao Exp $ */ public class LongJsonDeserializer extends JsonDeserializer&lt;Long&gt; { private static final Logger logger = LoggerFactory.getLogger(LongJsonDeserializer.class); // @Override // public Long deserialize(JsonParser p, DeserializationContext ctxt) throws IOException, JsonProcessingException { // return null; // } @Override public Long deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) throws IOException { String value = jsonParser.
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://ly19911114.github.io/post/jsonserialize%E4%B8%8Ejsondeserialize%E4%BD%BF%E7%94%A8/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
  
  <hr/>
  
  <article>
  <header>
    <h2><a href="https://ly19911114.github.io/post/%E5%85%B3%E4%BA%8Eredis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/">关于redis分布式锁</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2020-04-11T17:42:10&#43;08:00">
          Apr 11, 2020
        </time>
      </div>
    </div>
  </header>
  <div>
    
  </div>
  
</article>

  
  
  <hr/>
  
  <article>
  <header>
    <h2><a href="https://ly19911114.github.io/post/%E8%A7%A3%E5%86%B3idea%E6%BA%90%E7%A0%81%E6%B2%A1%E6%9C%89%E6%B3%A8%E9%87%8A/">解决IDEA源码没有注释</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2020-04-10T16:31:53&#43;08:00">
          Apr 10, 2020
        </time>
      </div>
    </div>
  </header>
  <div>
    当你的源码没有注释，但又想阅读注解，Download Sources也无效的时候，试试我这招，百试百灵，千言万语汇成一句话：在IDEA工具界面的左下角，有个点击Terminal，输入命令：mvn dependency:resolve -Dclassifier=sources，然后再点击Download Sources，OK，大功告成！
  </div>
  
</article>

  
  
  <hr/>
  
  <article>
  <header>
    <h2><a href="https://ly19911114.github.io/post/mybatis%E4%B8%ADlike%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2/">Mybatis中Like模糊查询</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2020-04-06T22:06:48&#43;08:00">
          Apr 6, 2020
        </time>
      </div>
    </div>
  </header>
  <div>
    模糊查询在项目中还是经常使用的，本文就简单整理Mybatis中使用Like进行模糊查询的几种写法以及一些常见的问题。
使用Springboot简单配置一下Mybatis，然后进行说明。Springboot集成Mybatis这里就不做介绍了。
初始数据 方式一 在Mybatis中的第一种写法：
&lt;!--有sql注入问题--&gt; &lt;select id=&quot;findUserByLikeName1&quot; parameterType=&quot;java.lang.String&quot; resultMap=&quot;user&quot;&gt; select * from t_user where name like '%${name}%' &lt;/select&gt;  这种会有sql注入的问题，需要明白在 Mybatis中 $ 和 # 使用的区别。这种写法也不能加jdbcType=VARCHAR,否则也会报错。
做了个简单的测试：
@Test public void findUserByLikeName1(){ List&lt;User&gt; test = userMapper.findUserByLikeName1(&quot;Cloud&quot;); //select * from t_user where name like '%Cloud%' System.out.println(test.size());// 查出一条 List&lt;User&gt; test1 = userMapper.findUserByLikeName1(&quot;' or '1=1&quot;); //select * from t_user where name like '%' or '1=1%' // 分析： '1=1%' 成立 System.out.println(test1.size());// 查出了全部数据 }  注意：排序的字段也容易出现这个问题，在使用的时候也一定要注意。
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://ly19911114.github.io/post/mybatis%E4%B8%ADlike%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
  
  <hr/>
  
  <article>
  <header>
    <h2><a href="https://ly19911114.github.io/post/%E6%B3%9B%E5%9E%8B%E8%AF%A6%E8%A7%A3/">泛型详解</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2020-04-04T11:46:14&#43;08:00">
          Apr 4, 2020
        </time>
      </div>
    </div>
  </header>
  <div>
    对java的泛型特性的了解仅限于表面的浅浅一层，直到在学习设计模式时发现有不了解的用法，才想起详细的记录一下。 本文参考java 泛型详解、Java中的泛型方法、 java泛型详解  1. 概述 泛型在java中有很重要的地位，在面向对象编程及各种设计模式中有非常广泛的应用。
什么是泛型？为什么要使用泛型？

泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。 泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。  
2. 一个栗子 一个被举了无数次的例子：

List arrayList = new ArrayList(); arrayList.add(&quot;aaaa&quot;); arrayList.add(100); for(int i = 0; i&lt; arrayList.size();i++){ String item = (String)arrayList.get(i); Log.d(&quot;泛型测试&quot;,&quot;item = &quot; + item); }  
毫无疑问，程序的运行结果会以崩溃结束：
java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String  ArrayList可以存放任意类型，例子中添加了一个String类型，添加了一个Integer类型，再使用时都以String的方式使用，因此程序崩溃了。为了解决类似这样的问题（在编译阶段就可以解决），泛型应运而生。
我们将第一行声明初始化list的代码更改一下，编译器会在编译阶段就能够帮我们发现类似这样的问题。
List&lt;String&gt; arrayList = new ArrayList&lt;String&gt;(); ... //arrayList.add(100); 在编译阶段，编译器就会报错  3. 特性 泛型只在编译阶段有效。看下面的代码：

List&lt;String&gt; stringArrayList = new ArrayList&lt;String&gt;(); List&lt;Integer&gt; integerArrayList = new ArrayList&lt;Integer&gt;(); Class classStringArrayList = stringArrayList.
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://ly19911114.github.io/post/%E6%B3%9B%E5%9E%8B%E8%AF%A6%E8%A7%A3/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
  
  <hr/>
  
  <article>
  <header>
    <h2><a href="https://ly19911114.github.io/post/%E6%B3%A8%E8%A7%A3data%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/">注解@Data的使用说明</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2020-04-01T21:53:48&#43;08:00">
          Apr 1, 2020
        </time>
      </div>
    </div>
  </header>
  <div>
    @Data 注解的主要作用是提高代码的简洁，使用这个注解可以省去代码中大量的get()、 set()、 toString()等方法；
引入lombok 要使用 @Data 注解要先引入lombok，lombok 是什么，它是一个工具类库，可以用简单的注解形式来简化代码，提高开发效率。
 在maven中添加依赖
&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.4&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt;  在编译器中添加插件 这里以IDEA为例，在setting的plugin里搜索lombok plugin，安装插件。
  使用 直接在相应的实体类上加上@Data注解即可；
比如一个简单的Person类，用常规的写法：
public class Person { private String name; private String address; private Integer age; private String hobbit; private String phone; public Person() { } public Person(String name, String address, Integer age, String hobbit, String phone) { this.name = name; this.address = address; this.age = age; this.
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://ly19911114.github.io/post/%E6%B3%A8%E8%A7%A3data%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
  
  <hr/>
  
  <article>
  <header>
    <h2><a href="https://ly19911114.github.io/post/%E5%85%B3%E4%BA%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">关于设计模式</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2020-03-27T00:01:55&#43;08:00">
          Mar 27, 2020
        </time>
      </div>
    </div>
  </header>
  <div>
    最近在读《Heade First设计模式》一书，收获颇多，代码放在GitHub仓库上，下载地址：https://github.com/ly19911114/design-mode.git
  </div>
  
</article>

  
  
  <hr/>
  
  <article>
  <header>
    <h2><a href="https://ly19911114.github.io/post/existinnot/">Exist,in;not</a></h2>
    <div class="post-meta clearfix">
      <div class="post-date pull-left">
        Posted on
        <time datetime="2020-03-22T18:48:26&#43;08:00">
          Mar 22, 2020
        </time>
      </div>
    </div>
  </header>
  <div>
    in 是把外表和内表作hash join，而exists是对外表作loop，每次loop再对内表进行查询。一般大家都认为exists比in语句的效率要高，这种说法其实是不准确的，这个是要区分环境的。
exists对外表用loop逐条查询，每次查询都会查看exists的条件语句，当 exists里的条件语句能够返回记录行时(无论记录行是的多少，只要能返回)，条件就为真，返回当前loop到的这条记录，反之如果exists里的条件语句不能返回记录行，则当前loop到的这条记录被丢弃，exists的条件就像一个bool条件，当能返回结果集则为true，不能返回结果集则为 false。
例如：
select * from user where exists (select 1);
对user表的记录逐条取出，由于子条件中的select 1永远能返回记录行，那么user表的所有记录都将被加入结果集，所以与 select * from user;是一样的
又如下
select * from user where exists (select * from user where userId = 0);
可以知道对user表进行loop时，检查条件语句(select * from user where userId = 0),由于userId永远不为0，所以条件语句永远返回空集，条件永远为false，那么user表的所有记录都将被丢弃
not exists与exists相反，也就是当exists条件有结果集返回时，loop到的记录将被丢弃，否则将loop到的记录加入结果集
总的来说，如果A表有n条记录，那么exists查询就是将这n条记录逐条取出，然后判断n遍exists条件
in查询相当于多个or条件的叠加，这个比较好理解，比如下面的查询
select * from user where userId in (1, 2, 3);
等效于
select * from user where userId = 1 or userId = 2 or userId = 3;
  </div>
  
  <footer>
    <ul class="pager">
      <li class="next"><a href="https://ly19911114.github.io/post/existinnot/">Read more <span aria-hidden="true">&raquo;</span></a></li>
    </ul>
  </footer>
  
</article>

  
</div>
<nav class="pagination" role="navigation">

  <hr />


  <span class="page-number">Page 1 of 3</span>

<a class="older-posts" href="/page/2/">Older Posts <span aria-hidden="true">&raquo;</span></a>

</nav>

  </main>
  <footer class="container global-footer">
    <div class="copyright-note pull-left">
      
    </div>
    <div class="sns-links hidden-print">
  
  
  
  
  
  
  
  
  
  
  
  
</div>

  </footer>

  <script src="https://ly19911114.github.io/js/highlight.pack.js"></script>
  <script>
    hljs.initHighlightingOnLoad();
  </script>
  
  
</body>
</html>


